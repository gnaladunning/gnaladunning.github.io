<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Realtime Compositional Geometry Analyzer - AR Web</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <style>
    html, body {
      margin:0; padding:0; width:100vw; height:100vh; background:#181818; color:#fff;
      overflow:hidden; overscroll-behavior:none; font-family:sans-serif;
    }
    #cameraFeed {
      position:fixed; left:0; top:0; width:100vw; height:100vh; object-fit:cover; z-index:0; background:#000;
    }
    #overlayCanvas {
      position:fixed; left:0; top:0; width:100vw; height:100vh; z-index:1; pointer-events:none;
    }
    .controls {
      position: absolute; right: 1em; top: 1em; z-index: 2; background:rgba(30,30,30,0.80);
      border-radius:8px; padding:.7em 1em; font-size:1em;
    }
    .controls label { display:block; margin-bottom:.3em; }
    #instructions {
      background:rgba(0,0,0,0.8); color:#fff; max-width:408px;
      margin:.6em auto; border-radius: 8px; padding: 11px; font-size:.99em;
      z-index: 3; position:relative; text-align:center;
    }
  </style>
</head>
<body>
  <div id="instructions">
    <b>Realtime Compositional Geometry AR Analyzer</b> (Experimental)<br>
    <ol style="padding-left:1.2em; text-align:left;">
      <li>Allow access to your camera if prompted.</li>
      <li>Point your device camera at images, artworks, or scenes.</li>
      <li>Compositional overlays will appear live over what you see.</li>
    </ol>
    <div style="margin-top:.7em; font-size:.92em;color:#cfa;">
      No need to upload a photo. Just move your camera over any composition.<br>For best results: use Safari on iOS or Chrome/Edge on Android.
    </div>
  </div>
  <div class="controls">
    <label><input type="checkbox" id="thirdsChk" checked> Rule of Thirds</label>
    <label><input type="checkbox" id="diagonalsChk" checked> Diagonals</label>
    <label><input type="checkbox" id="goldenChk"> Golden Ratio</label>
    <label><input type="checkbox" id="perspectiveChk"> Perspective</label>
    <label><input type="checkbox" id="curvesChk"> Dynamic Curves</label>
    <label><input type="checkbox" id="complexChk" checked> Complex Relationships</label>
  </div>
  <video id="cameraFeed" autoplay playsinline muted></video>
  <canvas id="overlayCanvas"></canvas>

  <script>
    // Camera
    const video = document.getElementById('cameraFeed');
    const canvas = document.getElementById('overlayCanvas');
    const ctx = canvas.getContext('2d');

    // Overlay checkbox state
    const overlays = {
      thirds: true,
      diagonals: true,
      golden: false,
      perspective: false,
      curves: false,
      complex: true
    };
    document.getElementById('thirdsChk').onchange = function(){ overlays.thirds = this.checked; };
    document.getElementById('diagonalsChk').onchange = function(){ overlays.diagonals = this.checked; };
    document.getElementById('goldenChk').onchange = function(){ overlays.golden = this.checked; };
    document.getElementById('perspectiveChk').onchange = function(){ overlays.perspective = this.checked; };
    document.getElementById('curvesChk').onchange = function(){ overlays.curves = this.checked; };
    document.getElementById('complexChk').onchange = function(){ overlays.complex = this.checked; };

    function resize() {
      const w = window.innerWidth, h = window.innerHeight;
      video.style.width = w+"px";
      video.style.height = h+"px";
      canvas.width = w;
      canvas.height = h;
    }
    window.addEventListener('resize', resize);
    window.addEventListener('orientationchange', resize);
    window.addEventListener('DOMContentLoaded', resize);

    // Camera setup
    async function startCamera(){
      try {
        if (!navigator.mediaDevices) throw new Error("No camera support");
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
        video.srcObject = stream;
        await video.play();
        document.getElementById('instructions').style.display = "none";
        requestAnimationFrame(drawOverlayGroup);
      } catch(e) {
        alert("Camera error: " + (e.message||e));
      }
    }
    startCamera();

    // Draw overlays on canvas
    function drawOverlayGroup() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const w = canvas.width, h = canvas.height;
      ctx.save();

      // Utility
      function line(x1,y1,x2,y2,col,lw=4,dash) {
        ctx.strokeStyle = col; ctx.globalAlpha = 0.95; ctx.lineWidth = lw;
        if(dash) ctx.setLineDash([dash, dash]);
        else ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
        ctx.stroke();
      }
      if(overlays.thirds){
        ctx.globalAlpha = 1;
        line(w/3,0,w/3,h,"#FFD600",4);
        line(w*2/3,0,w*2/3,h,"#FFD600",4);
        line(0,h/3,w,h/3,"#FFD600",4);
        line(0,h*2/3,w,h*2/3,"#FFD600",4);
      }
      if(overlays.diagonals){
        line(0,0,w,h,"#00D4F6",4);
        line(w,0,0,h,"#00D4F6",4);
        // Some dashed guides diagonally
        for(let i=1; i<=2; i++){
          line(w*i/3,0,w*i/3,h,"#00D4F6",2,12);
          line(0,h*i/3,w,h*i/3,"#00D4F6",2,12);
        }
      }
      if(overlays.golden){
        const phi = 0.618;
        line(w*phi,0,w*phi,h,"#51FF3D",3);
        line(w*(1-phi),0,w*(1-phi),h,"#51FF3D",3);
        line(0,h*phi,w,h*phi,"#51FF3D",3);
        line(0,h*(1-phi),w,h*(1-phi),"#51FF3D",3);
        // Golden spirals
        function goldenSpiral(cx,cy,flipX,flipY,col){
          const n = 80;
          let a=0, maxA=1.6*Math.PI;
          let r0 = Math.min(w,h)*0.49;
          ctx.strokeStyle = col; ctx.lineWidth = 2; ctx.setLineDash([]);
          ctx.beginPath();
          for(let i=0;i<=n;i++){
            let ang = a + maxA*i/n;
            let r = r0 * Math.pow(phi, ang/(2*Math.PI));
            let x = cx + flipX*r*Math.cos(ang);
            let y = cy + flipY*r*Math.sin(ang);
            if(i===0) ctx.moveTo(x,y);
            else ctx.lineTo(x,y);
          }
          ctx.stroke();
        }
        goldenSpiral(0,0,1,1,"#51FF3D");
        goldenSpiral(w,0,-1,1,"#51FF3D");
        goldenSpiral(0,h,1,-1,"#51FF3D");
        goldenSpiral(w,h,-1,-1,"#51FF3D");
      }
      if(overlays.perspective){
        let cx=w/2,cy=h/2;
        for(let i=0;i<11;i++){
          let ang=Math.PI*2*i/11;
          let rx=Math.cos(ang), ry=Math.sin(ang);
          line(cx,cy,cx+rx*w,cy+ry*h,"#FFA542",2.5);
        }
        for(let j=1;j<6;j++){
          let y=h*j/6;
          line(0,y,w,y,"#FFA542",1.5,8);
        }
      }
      if(overlays.curves){
        ctx.strokeStyle="#FFBF00";
        ctx.lineWidth=3;
        let C=[[w*0.14, h*0.07],[w-0.12*w, h-0.17*h],[w*0.21,h-0.10*h]];
        ctx.beginPath();
        for(let t=0; t<=1; t+=0.027){
          let x=(1-t)*(1-t)*C[0][0]+2*(1-t)*t*C[1][0]+t*t*C[2][0];
          let y=(1-t)*(1-t)*C[0][1]+2*(1-t)*t*C[1][1]+t*t*C[2][1];
          t===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
        // S curve
        ctx.strokeStyle="#94ffe2";
        let S=[[w*0.1,h*0.05],[w*0.6,h/2],[w*0.3,h-0.09*h],[w-0.08*w,h-0.04*h]];
        ctx.beginPath();
        for(let t=0;t<=1;t+=0.027){
          let x=Math.pow(1-t,3)*S[0][0]+3*Math.pow(1-t,2)*t*S[1][0]+3*(1-t)*t*t*S[2][0]+t*t*t*S[3][0];
          let y=Math.pow(1-t,3)*S[0][1]+3*Math.pow(1-t,2)*t*S[1][1]+3*(1-t)*t*t*S[2][1]+t*t*t*S[3][1];
          t===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
      }
      if(overlays.complex){
        ctx.strokeStyle="#DC5DF6";
        ctx.lineWidth=4.2;
        line(w/2,0,w/2,h,"#DC5DF6",4.2);
        line(0,h/2,w,h/2,"#DC5DF6",4.2);
        line(0,0,w,h,"#20F629",2.6);
        line(w,0,0,h,"#20F629",2.6);

        // Ellipse
        ctx.save();
        ctx.strokeStyle="#41FCFF";ctx.lineWidth=2;
        ctx.beginPath();
        ctx.ellipse(w/2,h/2,w*0.4,h*0.33,0,0,2*Math.PI);
        ctx.stroke();
        ctx.restore();

        // Star overlays
        function drawStar(cx,cy,r,points,col){
          ctx.save();
          ctx.strokeStyle=col; ctx.lineWidth=2;
          let step=2;
          for(let i=0;i<points;i++){
            let x1=cx + r*Math.cos((i/points)*2*Math.PI-Math.PI/2);
            let y1=cy + r*Math.sin((i/points)*2*Math.PI-Math.PI/2);
            for(let j=1;j<=Math.floor(points/2);j++){
              let x2=cx + r*Math.cos(((i+step*j)%points/points)*2*Math.PI-Math.PI/2);
              let y2=cy + r*Math.sin(((i+step*j)%points/points)*2*Math.PI-Math.PI/2);
              ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
            }
          }
          ctx.restore();
        }
        drawStar(w/2,h/2,Math.min(w,h)*0.24,5,"#FC3898");
        drawStar(w/2,h/2,Math.min(w,h)*0.20,6,"#45D1F6");
        for(let r=0;r<8;r++){
          let ang=Math.PI*2*r/8;
          line(w/2,h/2,w/2+Math.cos(ang)*(w/2),h/2+Math.sin(ang)*(h/2),"#FCA237",2);
        }
      }
      ctx.restore();
      requestAnimationFrame(drawOverlayGroup);
    }
  </script>
</body>
</html>
