<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TVTALK AR</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      touch-action: none;
      background: #000;
    }
    #politicalCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 2;
      pointer-events: none;
      background: transparent;
      object-fit: cover;
      display: block;
    }
    #videoElement {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      z-index: 1;
      background: #000;
    }
  </style>
</head>
<body>
  <video id="videoElement" autoplay playsinline muted></video>
  <canvas id="politicalCanvas"></canvas>
  <script>
    const politicalCanvas = document.getElementById('politicalCanvas');
    const video = document.getElementById('videoElement');
    const ctx = politicalCanvas.getContext('2d');

    // --- PARAMETERS ---
    const PARAGRAPH_INTERVAL = 160000;
    const FADE_DURATION = 30000;
    const APPEAR_DURATION = 30000;
    const DISAPPEAR_DURATION = 30000;
    const MAX_CLUSTERS = 5;

    // --- STATIC TEXT CYCLE ---
    const STATIC_TEXT_DURATION = 1000; // ms
    const STATIC_TEXT_MIN_INTERVAL = 3500; // ms
    const STATIC_TEXT_MAX_INTERVAL = 7000; // ms
    const LAST_TEXT_HISTORY = 10;

    // --- DESCRIPTIONS ---
    const descriptions = [
      "A group of friends discover strange events in their quiet town, uncovering secrets and facing challenges together as they navigate the mysteries hidden beneath the surface.",
      "An artist transforms recycled materials, creating beauty from waste.",
      "A scientist races against time to develop a breakthrough cure.",
      "A family embarks on a road trip, finding adventure and understanding.",
      "A detective unravels a complex web of lies in a small city.",
      "A musician finds inspiration in the sounds of everyday life.",
      "A chef creates fusion dishes, blending tradition and innovation.",
      "A teacher motivates students to pursue their dreams.",
      "A young athlete trains for the biggest competition of their life.",
      "A writer explores new worlds through imagination.",
      "An engineer builds a bridge connecting two communities.",
      "A child invents a game that sweeps the playground.",
      "A painter finds their muse in the changing seasons.",
      "A traveler learns the meaning of home far away.",
      "A doctor comforts patients with kindness and skill.",
      "An entrepreneur launches a startup that changes lives.",
      "A gardener cultivates rare flowers in a hidden corner.",
      "A programmer solves a bug after hours of effort.",
      "An astronaut gazes at Earth from the space station.",
      "A historian uncovers forgotten stories in old letters.",
      "A filmmaker captures moments that move audiences.",
      "A poet writes verses inspired by city lights.",
      "A volunteer brings hope to those in need.",
      "A designer reimagines a classic style for today.",
      "A cyclist races through mountain trails at sunrise.",
      "A dancer expresses emotions with every movement.",
      "A librarian helps readers discover favorite books.",
      "A parent supports a child’s first big step.",
      "A photographer freezes time in a stunning portrait.",
      "A coach cheers for every effort, win or lose.",
      "A nurse cares for others through long nights.",
      "A scientist unlocks the secrets of the sea.",
      "A singer shares melodies that lift spirits.",
      "A child dreams of exploring the stars.",
      "A baker crafts treats that delight the senses.",
      "A student overcomes obstacles with persistence.",
      "A mentor guides the next generation with wisdom.",
      "A novelist finishes the final chapter.",
      "A couple celebrates years of shared adventure.",
      "A pilot lands smoothly after a stormy flight.",
      "A comedian brings laughter to a quiet crowd.",
      "A runner breaks a personal record at dawn.",
      "A sculptor shapes visions from raw stone.",
      "A researcher makes a key discovery in the lab.",
      "A community comes together for a festival.",
      "A dog finds a forever home with loving owners.",
      "A firefighter saves lives with courage.",
      "A gamer reaches a new high score.",
      "A botanist catalogs new plant species.",
      "A social worker listens and understands.",
      "A surfer catches the perfect wave.",
      "A mathematician solves a complex puzzle.",
      "A chef reinvents a family recipe.",
      "A scientist tracks migratory birds.",
      "A teacher sees a student succeed.",
      "A musician improvises a moving solo.",
      "A traveler finds joy in unexpected places.",
      "A child learns to ride a bike.",
      "A journalist reports on a breakthrough story.",
      "A family gathers for a holiday meal.",
      "A volunteer cleans up a local park.",
      "A craftsman restores an antique chair.",
      "A coder builds an innovative app.",
      "A neighbor helps during a storm.",
      "A nurse comforts a worried patient.",
      "A student presents a big project.",
      "An artist sketches in a busy café.",
      "A hiker reaches a breathtaking summit.",
      "A pilot soars above the clouds.",
      "A poet shares words at an open mic.",
      "A swimmer wins a tough race.",
      "A teacher celebrates a milestone.",
      "A gardener plants seeds for spring.",
      "An explorer maps an unknown region.",
      "A dancer leaps across the stage.",
      "A novelist shares a new book.",
      "A parent reads bedtime stories.",
      "A scientist launches a satellite.",
      "A chef prepares a special feast.",
      "A child builds a castle in the sand.",
      "A musician plays an encore.",
      "A photographer captures a rare moment.",
      "A student aces a difficult exam.",
      "A volunteer tutors young learners.",
      "A runner joins a marathon.",
      "A designer unveils a new look.",
      "A coach inspires teamwork.",
      "A historian presents new findings.",
      "A librarian organizes a community event.",
      "A botanist discovers unique flora.",
      "A doctor pioneers a new treatment.",
      "A cyclist explores winding paths.",
      "A programmer launches a creative project.",
      "A mentor celebrates student success.",
      "A swimmer enjoys a peaceful lake.",
      "A teacher leads a fun field trip.",
      "A singer records a first album.",
      "A gardener grows a lush orchard.",
      "A neighbor hosts a summer barbecue.",
      "A researcher publishes a breakthrough.",
      "A comedian improvises a witty skit."
    ];

    // --- UTILITIES ---
    function pickDescription() {
      return descriptions[Math.floor(Math.random() * descriptions.length)];
    }

    function wrapTextWords(text, maxWordsPerLine = 9, minWordsPerLine = 5) {
      const words = text.split(/\s+/);
      const lines = [];
      let i = 0;
      while (i < words.length) {
        let lineWords = words.slice(i, i + maxWordsPerLine);
        if (lineWords.length < minWordsPerLine && i + maxWordsPerLine < words.length) {
          lineWords = words.slice(i, i + minWordsPerLine);
          i += minWordsPerLine;
        } else {
          i += lineWords.length;
        }
        lines.push(lineWords.join(' '));
      }
      return lines;
    }

    function isWideRangeColor(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      let max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = ((g - b) / d + (g < b ? 6 : 0)); break;
          case g: h = ((b - r) / d + 2); break;
          case b: h = ((r - g) / d + 4); break;
        }
        h /= 6;
      }
      const greenish = h >= 0.2 && h <= 0.45;
      const yellowish = h >= 0.12 && h < 0.2;
      const cyanish = h > 0.45 && h < 0.55;
      const bright = l > 0.28;
      const colorful = s > 0.35;
      return (greenish || yellowish || cyanish) && bright && colorful;
    }

    function clusterColorPixels(data, width, height) {
      const visited = new Uint8Array(width * height);
      const clusters = [];
      const pixelIndex = (x, y) => (y * width + x) * 4;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          if (visited[idx]) continue;
          const i = pixelIndex(x, y);
          if (isWideRangeColor(data[i], data[i + 1], data[i + 2])) {
            const queue = [[x, y]];
            const cluster = [];
            let minX = x, maxX = x, minY = y, maxY = y;
            visited[idx] = 1;
            while (queue.length) {
              const [cx, cy] = queue.pop();
              cluster.push([cx, cy]);
              minX = Math.min(minX, cx); maxX = Math.max(maxX, cx);
              minY = Math.min(minY, cy); maxY = Math.max(maxY, cy);
              for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                  const nx = cx + dx, ny = cy + dy;
                  if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                  const nidx = ny * width + nx;
                  if (!visited[nidx]) {
                    const ni = pixelIndex(nx, ny);
                    if (isWideRangeColor(data[ni], data[ni + 1], data[ni + 2])) {
                      queue.push([nx, ny]);
                      visited[nidx] = 1;
                    }
                  }
                }
              }
            }
            if (
              cluster.length > 18 &&
              minX > 0 && maxX < width - 1 &&
              minY > 0 && maxY < height - 1
            ) {
              clusters.push(cluster);
              if (clusters.length >= MAX_CLUSTERS) return clusters;
            }
          }
        }
      }
      return clusters;
    }

    function getClusterCenter(cluster) {
      let sumX = 0, sumY = 0;
      for (const [x, y] of cluster) {
        sumX += x;
        sumY += y;
      }
      return [sumX / cluster.length, sumY / cluster.length];
    }

    function getClusterSize(cluster) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const [x, y] of cluster) {
        minX = Math.min(minX, x); maxX = Math.max(maxX, x);
        minY = Math.min(minY, y); maxY = Math.max(maxY, y);
      }
      return Math.sqrt((maxX - minX) * (maxY - minY) + cluster.length);
    }

    // --- CLUSTER STATE ---
    let clusterStates = [];
    let prevClusterCenters = [];
    let lastParagraphTrigger = Date.now();

    function clustersAreDifferent(currentCenters, prevCenters) {
      if (currentCenters.length !== prevCenters.length) return true;
      for (let i = 0; i < currentCenters.length; i++) {
        if (!prevCenters[i] || Math.abs(currentCenters[i][0] - prevCenters[i][0]) > 25 || Math.abs(currentCenters[i][1] - prevCenters[i][1]) > 25) {
          return true;
        }
      }
      return false;
    }

    function updateClusters(currentCenters, currentSizes, forceRefreshDescriptions = false) {
      let newStates = [];
      let matched = new Set();
      for (let i = 0; i < currentCenters.length; i++) {
        let center = currentCenters[i];
        let size = currentSizes[i];
        let foundIdx = -1, minDist = Infinity;
        for (let j = 0; j < clusterStates.length; j++) {
          let prev = clusterStates[j];
          if (prev.status === "disappearing") continue;
          let dist = Math.hypot(center[0] - prev.center[0], center[1] - prev.center[1]);
          if (dist < 60 && dist < minDist && !matched.has(j)) {
            minDist = dist;
            foundIdx = j;
          }
        }
        if (foundIdx !== -1) {
          let prev = clusterStates[foundIdx];
          newStates.push({
            ...prev,
            size,
            appearStart: prev.appearStart,
            status: "visible",
            disappearStart: null,
            lastUpdate: Date.now(),
            description: forceRefreshDescriptions ? pickDescription() : prev.description,
            nextDescription: forceRefreshDescriptions ? pickDescription() : prev.nextDescription,
            descFade: 1,
            descLastChange: Date.now()
          });
          matched.add(foundIdx);
        } else {
          newStates.push({
            center,
            size,
            description: pickDescription(),
            nextDescription: pickDescription(),
            descFade: 1,
            descLastChange: Date.now(),
            appearStart: Date.now(),
            status: "appearing",
            disappearStart: null,
            depth: Math.random(),
            lastUpdate: Date.now()
          });
        }
      }
      for (let j = 0; j < clusterStates.length; j++) {
        if (matched.has(j)) continue;
        let prev = clusterStates[j];
        if (prev.status === "disappearing" && prev.disappearStart && Date.now() - prev.disappearStart < DISAPPEAR_DURATION) {
          newStates.push(prev);
        } else if (prev.status !== "disappearing") {
          newStates.push({
            ...prev,
            status: "disappearing",
            disappearStart: Date.now()
          });
        }
      }
      clusterStates = newStates.slice(0, MAX_CLUSTERS);
    }

    function updateDescriptionTransitions() {
      const now = Date.now();
      for (let cluster of clusterStates) {
        if (cluster.status === "appearing" && cluster.appearStart) {
          let t = (now - cluster.appearStart) / APPEAR_DURATION;
          cluster.appearProgress = Math.min(1, t);
          if (cluster.appearProgress >= 1) {
            cluster.status = "visible";
            cluster.appearStart = null;
            cluster.appearProgress = 1;
          }
        }
        if (cluster.status === "disappearing" && cluster.disappearStart) {
          let t = (now - cluster.disappearStart) / DISAPPEAR_DURATION;
          cluster.disappearProgress = Math.min(1, t);
        }
        cluster.descFade = 1;
      }
    }

    function triggerDescriptionChanges() {
      for (let cluster of clusterStates) {
        cluster.nextDescription = pickDescription();
        cluster.descFade = 1;
        cluster.descLastChange = Date.now();
        cluster.depth = Math.random();
      }
    }

    function getSplinePoints(points, tension = 0.5, numOfSeg = 18) {
      if (points.length < 2) return points;
      let result = [];
      for (let i = 0; i < points.length - 1; i++) {
        let p0 = points[i === 0 ? i : i - 1];
        let p1 = points[i];
        let p2 = points[i + 1];
        let p3 = points[i + 2 < points.length ? i + 2 : i + 1];
        for (let t = 0; t < numOfSeg; t++) {
          let st = t / numOfSeg;
          let x = catmullRom(p0[0], p1[0], p2[0], p3[0], st, tension);
          let y = catmullRom(p0[1], p1[1], p2[1], p3[1], st, tension);
          result.push([x, y]);
        }
      }
      return result;
    }

    function catmullRom(p0, p1, p2, p3, t, tension) {
      let v0 = (p2 - p0) * tension;
      let v1 = (p3 - p1) * tension;
      return (2 * p1 - 2 * p2 + v0 + v1) * t * t * t
           + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t * t
           + v0 * t
           + p1;
    }

    // --- STATIC TEXT CYCLE STATE ---
    let lastClusterTexts = [];
    let staticTextActive = false;
    let staticTextValue = "";
    let staticTextStartTime = 0;
    let staticTextNextTrigger = Date.now() + getRandomStaticTextDelay();

    function getRandomStaticTextDelay() {
      return STATIC_TEXT_MIN_INTERVAL + Math.random() * (STATIC_TEXT_MAX_INTERVAL - STATIC_TEXT_MIN_INTERVAL);
    }

    function pushClusterTexts() {
      let currentTexts = clusterStates.map(c => c.description);
      for (let txt of currentTexts) {
        if (txt && lastClusterTexts[lastClusterTexts.length-1] !== txt) {
          lastClusterTexts.push(txt);
        }
      }
      if (lastClusterTexts.length > LAST_TEXT_HISTORY) {
        lastClusterTexts = lastClusterTexts.slice(-LAST_TEXT_HISTORY);
      }
    }

    // --- STATIC TEXT DRAWING (Camera Field of View Only) ---
    function getMaxFontSizeForText(lines, canvasWidth, canvasHeight, padding = 24) {
      let maxFontSize = 80, minFontSize = 20, fontSize = maxFontSize;
      let fits = false;
      while (!fits && fontSize >= minFontSize) {
        ctx.save();
        ctx.font = `bold ${fontSize}px Arial, sans-serif`;
        let lineWidths = lines.map(l => ctx.measureText(l).width);
        let maxLineWidth = Math.max(...lineWidths);
        let lineHeight = fontSize * 1.3;
        let totalHeight = lineHeight * lines.length;
        fits = maxLineWidth + padding * 2 <= canvasWidth && totalHeight + padding * 2 <= canvasHeight;
        ctx.restore();
        if (!fits) fontSize -= 2;
      }
      return Math.max(fontSize, minFontSize);
    }

    function getCameraDrawBounds(video, canvas) {
      // Calculate the camera FOV on the canvas based on aspect ratios and object-fit cover logic
      const videoAR = video.videoWidth / video.videoHeight;
      const canvasAR = canvas.width / canvas.height;
      let camX = 0, camY = 0, camW = canvas.width, camH = canvas.height;
      if (canvasAR > videoAR) {
        // Canvas is wider than video: video fills height, cropped left/right
        camH = canvas.height;
        camW = videoAR * camH;
        camX = Math.round((canvas.width - camW) / 2);
        camY = 0;
      } else {
        // Canvas is taller than video: video fills width, cropped top/bottom
        camW = canvas.width;
        camH = camW / videoAR;
        camX = 0;
        camY = Math.round((canvas.height - camH) / 2);
      }
      return { camX, camY, camW, camH };
    }

    function drawStaticText(ctx, text) {
      ctx.save();
      let canvasWidth = politicalCanvas.width;
      let canvasHeight = politicalCanvas.height;

      // Get camera FOV bounds on the canvas
      let { camX, camY, camW, camH } = getCameraDrawBounds(video, politicalCanvas);

      let padding = Math.round(camW * 0.06);

      // Center and fit within camera FOV
      let lines = wrapTextWords(text, 9, 5);
      let fontSize = getMaxFontSizeForText(lines, camW, camH, padding);

      ctx.font = `bold ${fontSize}px Arial, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = "#FF2020";
      ctx.shadowColor = "#000";
      ctx.shadowBlur = 24;

      // Calculate total height and origin in camera FOV
      let lineHeight = fontSize * 1.3;
      let totalHeight = lineHeight * lines.length;
      let centerX = camX + camW / 2;
      let centerY = camY + camH / 2;

      // Draw all lines centered in camera FOV only
      for (let j = 0; j < lines.length; j++) {
        ctx.fillText(lines[j], centerX, centerY + (j - (lines.length-1)/2) * lineHeight);
      }
      ctx.restore();
    }

    function drawColorOverlays(ctx, clusters) {
      updateDescriptionTransitions();
      ctx.save();
      let centers = clusters.filter(c => c.status !== "disappearing" || (c.status === "disappearing" && c.disappearProgress < 1)).map(c => c.center);
      if (centers.length >= 2) {
        let spline = getSplinePoints(centers, 0.5, 18);
        ctx.beginPath();
        ctx.strokeStyle = "#FF4141";
        ctx.lineWidth = 2.5;
        ctx.globalAlpha = 0.38;
        for (let i = 0; i < spline.length - 1; i++) {
          let [x1, y1] = spline[i];
          let [x2, y2] = spline[i + 1];
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
        }
        ctx.stroke();
        ctx.globalAlpha = 1.0;
      }
      for (let i = 0; i < clusters.length; i++) {
        let cluster = clusters[i];
        let [x, y] = cluster.center;
        let z = cluster.depth || 0;
        let size = cluster.size;

        let minFont = 32, maxFont = 72;
        let norm = Math.max(0, Math.min(1, (size - 120) / (politicalCanvas.width * 0.13)));
        let fontSize = Math.round(minFont + norm * (maxFont - minFont) * (1 - z * 0.5));

        let alpha = 1.0;
        let appearAlpha = 1.0;
        if (cluster.status === "appearing") appearAlpha = cluster.appearProgress || 0;
        if (cluster.status === "disappearing") appearAlpha = 1 - (cluster.disappearProgress || 0);
        alpha *= appearAlpha;

        let desc = cluster.description;
        let descAlpha = alpha;

        ctx.save();
        let centerX = politicalCanvas.width / 2;
        let centerY = politicalCanvas.height / 2;
        let staticX = x * 0.5 + centerX * 0.5;
        let staticY = y * 0.5 + centerY * 0.5;
        ctx.translate(staticX, staticY);

        ctx.font = `bold ${fontSize}px Arial, sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.globalAlpha = descAlpha;
        ctx.fillStyle = "#FF2020";
        ctx.shadowColor = "#000";
        ctx.shadowBlur = 18;

        const lines = wrapTextWords(desc, 9, 5);
        let lineHeight = fontSize * 1.3;
        for (let j = 0; j < lines.length; j++) {
          ctx.fillText(lines[j], 0, (j - (lines.length-1)/2) * lineHeight);
        }
        ctx.restore();
      }
      ctx.restore();
    }

    // --- MAIN DRAW LOOP ---
    let staticCanvasFrame = null;
    function draw() {
      const now = Date.now();

      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        // Resize canvas if video frame changes
        if (politicalCanvas.width !== video.videoWidth || politicalCanvas.height !== video.videoHeight) {
          politicalCanvas.width = video.videoWidth;
          politicalCanvas.height = video.videoHeight;
          staticCanvasFrame = null;
        }

        // Draw camera frame as background (canvas overlays, so just clear canvas)
        ctx.clearRect(0, 0, politicalCanvas.width, politicalCanvas.height);

        // Check static text trigger
        if (!staticTextActive && now >= staticTextNextTrigger && lastClusterTexts.length > 0) {
          staticTextValue = lastClusterTexts[Math.floor(Math.random() * lastClusterTexts.length)];
          staticTextActive = true;
          staticTextStartTime = now;
        }

        // End static text after duration
        if (staticTextActive && now - staticTextStartTime >= STATIC_TEXT_DURATION) {
          staticTextActive = false;
          staticTextValue = "";
          staticTextNextTrigger = now + getRandomStaticTextDelay();
        }

        let frame = ctx.getImageData(0, 0, politicalCanvas.width, politicalCanvas.height);
        let data = frame.data;
        let clusters;
        let clusterCenters, clusterAreaSizes;

        clusters = clusterColorPixels(data, politicalCanvas.width, politicalCanvas.height);
        clusterCenters = clusters.map(getClusterCenter);
        clusterAreaSizes = clusters.map(getClusterSize);

        let forceRefresh = clustersAreDifferent(clusterCenters, prevClusterCenters);
        if (forceRefresh && clusterCenters.length > 0) {
          updateClusters(clusterCenters, clusterAreaSizes, true);
          triggerDescriptionChanges();
          lastParagraphTrigger = Date.now();
        } else if (Date.now() - lastParagraphTrigger >= PARAGRAPH_INTERVAL) {
          updateClusters(clusterCenters, clusterAreaSizes, true);
          triggerDescriptionChanges();
          lastParagraphTrigger = Date.now();
        } else if (clusterStates.length === 0) {
          updateClusters(clusterCenters, clusterAreaSizes, true);
          triggerDescriptionChanges();
        } else {
          updateClusters(clusterCenters, clusterAreaSizes, false);
        }
        prevClusterCenters = clusterCenters;

        pushClusterTexts();

        if (staticTextActive && staticTextValue) {
          // Overlay static text over live video directly, do not black out screen
          drawStaticText(ctx, staticTextValue);
        } else {
          drawColorOverlays(ctx, clusterStates);
        }
      }
      requestAnimationFrame(draw);
    }

    // --- CAMERA SETUP ---
    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false })
      .then(stream => {
        video.srcObject = stream;
        video.play();
        video.addEventListener('loadedmetadata', () => {
          politicalCanvas.width = video.videoWidth;
          politicalCanvas.height = video.videoHeight;
          draw();
        });
      })
      .catch(() => {
        alert('Camera access denied or unavailable.');
      });

    // --- RESIZE HANDLERS ---
    window.addEventListener('resize', () => {
      politicalCanvas.width = window.innerWidth;
      politicalCanvas.height = window.innerHeight;
      staticCanvasFrame = null;
    });

    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        politicalCanvas.width = window.innerWidth;
        politicalCanvas.height = window.innerHeight;
        staticCanvasFrame = null;
      }, 500);
    });
  </script>
</body>
</html>
