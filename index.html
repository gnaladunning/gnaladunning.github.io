```html name=index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Political Disenfranchisement AR</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      touch-action: none;
      background: #000;
    }
    #politicalCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      pointer-events: none;
      background: #000;
      object-fit: cover;
      display: block;
    }
    #videoElement {
      display: none;
    }
  </style>
</head>
<body>
  <video id="videoElement" autoplay playsinline muted></video>
  <canvas id="politicalCanvas"></canvas>
  <script>
    const politicalCanvas = document.getElementById('politicalCanvas');
    const video = document.getElementById('videoElement');
    const ctx = politicalCanvas.getContext('2d');

    // AR Word/Cluster settings
    const WORD_INTERVAL = 7000;  // ms per word
    const FADE_DURATION = 3500;  // ms for fade transition
    const MAX_WORDS = 30;

    // Words associated with political disenfranchisement
    const disenfranchisementWords = [
      "suppression", "gerrymandering", "disenfranchisement", "barrier", "inequality", "exclusion", "marginalized", "voter ID", "poll tax", "intimidation",
      "redlining", "obstruction", "discrimination", "disqualification", "apartheid", "segregation", "restriction", "displacement", "censorship", "disempowerment",
      "undercount", "injustice", "alienation", "disadvantage", "minority rule", "corruption", "voter purge", "felony disenfranchisement", "abstention", "silenced",
      "access denied", "systemic bias", "obstacles", "manipulation", "vote dilution", "unfair districts", "limited access", "exclusion zone", "lack of representation",
      "absentee barriers", "citizenship test", "provisional ballot", "closed polls", "language barrier", "misinformation", "malapportionment", "disqualified", "lost vote",
      "protest", "boycott", "disinterested", "apathy", "underrepresentation", "unaccountable", "political isolation", "unheard voices"
      // Add more as needed
    ];

    // Expanded color sampling (keep original logic for greenish/cyan/yellowish)
    function isWideRangeColor(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      let max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = ((g - b) / d + (g < b ? 6 : 0)); break;
          case g: h = ((b - r) / d + 2); break;
          case b: h = ((r - g) / d + 4); break;
        }
        h /= 6;
      }
      const greenish = h >= 0.2 && h <= 0.45;
      const yellowish = h >= 0.12 && h < 0.2;
      const cyanish = h > 0.45 && h < 0.55;
      const bright = l > 0.28;
      const colorful = s > 0.35;
      return (greenish || yellowish || cyanish) && bright && colorful;
    }

    // Cluster detection with flag for clusters moving out of view
    function clusterColorPixels(data, width, height) {
      const visited = new Uint8Array(width * height);
      const clusters = [];
      const pixelIndex = (x, y) => (y * width + x) * 4;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          if (visited[idx]) continue;
          const i = pixelIndex(x, y);
          if (isWideRangeColor(data[i], data[i + 1], data[i + 2])) {
            const queue = [[x, y]];
            const cluster = [];
            let minX = x, maxX = x, minY = y, maxY = y;
            visited[idx] = 1;
            while (queue.length) {
              const [cx, cy] = queue.pop();
              cluster.push([cx, cy]);
              minX = Math.min(minX, cx); maxX = Math.max(maxX, cx);
              minY = Math.min(minY, cy); maxY = Math.max(maxY, cy);
              for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                  const nx = cx + dx, ny = cy + dy;
                  if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                  const nidx = ny * width + nx;
                  if (!visited[nidx]) {
                    const ni = pixelIndex(nx, ny);
                    if (isWideRangeColor(data[ni], data[ni + 1], data[ni + 2])) {
                      queue.push([nx, ny]);
                      visited[nidx] = 1;
                    }
                  }
                }
              }
            }
            // Only keep clusters fully visible
            if (
              cluster.length > 18 &&
              minX > 0 && maxX < width - 1 &&
              minY > 0 && maxY < height - 1
            ) {
              clusters.push(cluster);
              if (clusters.length >= MAX_WORDS) return clusters;
            }
          }
        }
      }
      return clusters;
    }

    function getClusterCenter(cluster) {
      let sumX = 0, sumY = 0;
      for (const [x, y] of cluster) {
        sumX += x;
        sumY += y;
      }
      return [sumX / cluster.length, sumY / cluster.length];
    }

    function getClusterSize(cluster) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const [x, y] of cluster) {
        minX = Math.min(minX, x); maxX = Math.max(maxX, x);
        minY = Math.min(minY, y); maxY = Math.max(maxY, y);
      }
      return Math.sqrt((maxX - minX) * (maxY - minY) + cluster.length); // area proxy
    }

    function pickWord() {
      return disenfranchisementWords[Math.floor(Math.random() * disenfranchisementWords.length)];
    }

    let clusterWords = [];
    let clusterNextWords = [];
    let clusterFadeProgress = [];
    let clusterLastChange = [];
    let clusterDepths = [];
    let clusterSizes = [];

    function syncClusterArrays(n, sizes) {
      if (clusterWords.length !== n) {
        clusterWords = [];
        clusterNextWords = [];
        clusterFadeProgress = [];
        clusterLastChange = [];
        clusterDepths = [];
        clusterSizes = [];
        for (let i = 0; i < n; i++) {
          clusterWords.push(pickWord());
          clusterNextWords.push(pickWord());
          clusterFadeProgress.push(1);
          clusterLastChange.push(Date.now());
          clusterDepths.push(Math.random());
          clusterSizes.push(sizes[i]);
        }
      } else {
        for (let i = 0; i < n; i++) {
          clusterSizes[i] = sizes[i];
        }
      }
    }

    function triggerNextWords() {
      for (let i = 0; i < clusterWords.length; i++) {
        clusterNextWords[i] = pickWord();
        clusterFadeProgress[i] = 0;
        clusterLastChange[i] = Date.now();
        clusterDepths[i] = Math.random();
      }
    }

    function updateFade() {
      const now = Date.now();
      for (let i = 0; i < clusterFadeProgress.length; i++) {
        if (clusterFadeProgress[i] < 1) {
          let t = (now - clusterLastChange[i]) / FADE_DURATION;
          clusterFadeProgress[i] = Math.min(1, t);
          if (clusterFadeProgress[i] >= 1) {
            clusterWords[i] = clusterNextWords[i];
          }
        }
      }
    }

    // Spline for smooth curves
    function getSplinePoints(points, tension = 0.5, numOfSeg = 18) {
      if (points.length < 2) return points;
      let result = [];
      for (let i = 0; i < points.length - 1; i++) {
        let p0 = points[i === 0 ? i : i - 1];
        let p1 = points[i];
        let p2 = points[i + 1];
        let p3 = points[i + 2 < points.length ? i + 2 : i + 1];
        for (let t = 0; t < numOfSeg; t++) {
          let st = t / numOfSeg;
          let x = catmullRom(p0[0], p1[0], p2[0], p3[0], st, tension);
          let y = catmullRom(p0[1], p1[1], p2[1], p3[1], st, tension);
          result.push([x, y]);
        }
      }
      return result;
    }

    function catmullRom(p0, p1, p2, p3, t, tension) {
      let v0 = (p2 - p0) * tension;
      let v1 = (p3 - p1) * tension;
      return (2 * p1 - 2 * p2 + v0 + v1) * t * t * t
           + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t * t
           + v0 * t
           + p1;
    }

    function drawColorOverlays(ctx, centers, sizes) {
      updateFade();
      ctx.save();
      if (centers.length >= 2) {
        let spline = getSplinePoints(centers, 0.5, 18);
        ctx.beginPath();
        ctx.strokeStyle = "#FF4141";
        ctx.lineWidth = 2.5;
        ctx.shadowColor = "#FF4141";
        ctx.shadowBlur = 16;
        for (let i = 0; i < spline.length - 1; i++) {
          let [x1, y1] = spline[i];
          let [x2, y2] = spline[i + 1];
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
        }
        ctx.globalAlpha = 0.45;
        ctx.stroke();
        ctx.globalAlpha = 1.0;
      }
      // Words at cluster centers, distributed and scaled by size (proximity)
      for (let i = 0; i < centers.length; i++) {
        let [x, y] = centers[i];
        let z = clusterDepths[i];
        let size = sizes[i];
        // Camera proximity proxy: larger cluster area == closer
        let minFont = 18, maxFont = 80;
        // Normalize area based on canvas size for scaling, clamp to reasonable range
        let norm = Math.max(0, Math.min(1, (size - 120) / (politicalCanvas.width * 0.13)));
        let fontSize = Math.round(minFont + norm * (maxFont - minFont) * (1 - z * 0.5));
        let minAlpha = 0.52, maxAlpha = 0.88;
        let alpha = maxAlpha - z * (maxAlpha - minAlpha);
        let fade = clusterFadeProgress[i];

        ctx.save();
        ctx.translate(x, y);
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "#FF4141";
        ctx.shadowBlur = 20;

        let word, wordAlpha;
        if (fade < 1) {
          word = clusterNextWords[i];
          wordAlpha = alpha * fade;
        } else {
          word = clusterWords[i];
          wordAlpha = alpha;
        }
        ctx.globalAlpha = wordAlpha;
        ctx.fillStyle = "#FF4141";
        ctx.fillText(word, 0, 0);

        ctx.restore();
      }
      ctx.restore();
    }

    let lastWordTrigger = Date.now();
    let prevCenters = [];
    let prevSizes = [];

    function draw() {
      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        if (politicalCanvas.width !== video.videoWidth || politicalCanvas.height !== video.videoHeight) {
          politicalCanvas.width = video.videoWidth;
          politicalCanvas.height = video.videoHeight;
        }
        // Blur, brightness, and contrast for sampling
        ctx.filter = "blur(1.5px) brightness(1.18) contrast(1.18)";
        ctx.drawImage(video, 0, 0, politicalCanvas.width, politicalCanvas.height);
        ctx.filter = "none";
        let frame = ctx.getImageData(0, 0, politicalCanvas.width, politicalCanvas.height);
        let data = frame.data;
        let clusters = clusterColorPixels(data, politicalCanvas.width, politicalCanvas.height);
        let clusterCenters = clusters.map(getClusterCenter);
        let clusterAreaSizes = clusters.map(getClusterSize);

        let nWords = Math.min(clusterCenters.length, MAX_WORDS);
        clusterCenters = clusterCenters.slice(0, nWords);
        clusterAreaSizes = clusterAreaSizes.slice(0, nWords);

        // Look for new clusters as old clusters move out of view
        syncClusterArrays(nWords, clusterAreaSizes);

        // If clusters have changed or moved out, update instantly
        let centersChanged = false;
        if (prevCenters.length !== clusterCenters.length) {
          centersChanged = true;
        } else {
          for (let i = 0; i < clusterCenters.length; i++) {
            if (
              Math.abs(clusterCenters[i][0] - (prevCenters[i]?.[0] || 0)) > 80 ||
              Math.abs(clusterCenters[i][1] - (prevCenters[i]?.[1] || 0)) > 80
            ) {
              centersChanged = true;
              break;
            }
          }
        }
        if (centersChanged) {
          triggerNextWords();
          lastWordTrigger = Date.now();
        }
        prevCenters = clusterCenters.slice();
        prevSizes = clusterAreaSizes.slice();

        if (Date.now() - lastWordTrigger >= WORD_INTERVAL) {
          triggerNextWords();
          lastWordTrigger = Date.now();
        }
        drawColorOverlays(ctx, clusterCenters, clusterAreaSizes);
      }
      requestAnimationFrame(draw);
    }

    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false })
      .then(stream => {
        video.srcObject = stream;
        video.play();
        video.addEventListener('loadedmetadata', () => {
          politicalCanvas.width = video.videoWidth;
          politicalCanvas.height = video.videoHeight;
          draw();
        });
      })
      .catch(() => {
        alert('Camera access denied or unavailable.');
      });

    window.addEventListener('resize', () => {
      politicalCanvas.width = window.innerWidth;
      politicalCanvas.height = window.innerHeight;
    });

    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        politicalCanvas.width = window.innerWidth;
        politicalCanvas.height = window.innerHeight;
      }, 500);
    });
  </script>
</body>
</html>
```
