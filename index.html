<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Live Camera + Animated Bar Chart Overlay</title>
  <style>
    html,body { height:100%; margin:0; background:#000; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; color:#eee; }
    #container { position:relative; width:100%; height:100vh; overflow:hidden; }
    video#cam {
      position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform:scaleX(-1); /* mirror for user camera */
    }
    canvas#overlay {
      position:absolute; inset:0; width:100%; height:100%; pointer-events:none;
      background:transparent;
    }
    #ui {
      position:absolute; left:12px; top:12px; z-index:10; background:rgba(0,0,0,0.45); padding:10px; border-radius:8px;
      backdrop-filter: blur(6px);
    }
    #ui input[type="text"] { width:420px; max-width:40vw; }
    #status { margin-top:6px; font-size:0.9rem; color:#9cf; }
    button { margin-left:6px; }
    .small { font-size:0.9rem; color:#bbb; }
  </style>
</head>
<body>
  <div id="container">
    <video id="cam" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>

    <div id="ui">
      <div>
        Data source URL:
        <input id="source" type="text" placeholder="Enter JSON/line endpoint or proxy SSE URL"
          value="http://rs.local/sse" />
        <button id="connect">Connect</button>
        <button id="disconnect" disabled>Disconnect</button>
      </div>
      <div style="margin-top:8px">
        Poll interval (ms, for non-SSE): <input id="poll" type="number" value="200" style="width:90px" />
        Max bars in view: <input id="maxSamples" type="number" value="64" style="width:90px" />
      </div>
      <div id="status">Status: idle</div>
      <div style="margin-top:8px" class="small">
        Notes: If you enter <code>http://rs.local/...</code> it will automatically be rewritten to a localhost proxy
        (http://localhost:3000/sse?url=...) so pages served over HTTPS won't be blocked by mixed-content. If the
        remote data server blocks CORS, run a proxy on localhost:3000 that adds Access-Control-Allow-Origin.
      </div>
    </div>
  </div>

  <script>
  (function(){
    const video = document.getElementById('cam');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const connectBtn = document.getElementById('connect');
    const disconnectBtn = document.getElementById('disconnect');
    const statusEl = document.getElementById('status');
    const sourceInput = document.getElementById('source');
    const pollInput = document.getElementById('poll');
    const maxSamplesInput = document.getElementById('maxSamples');

    // Camera start
    async function startCamera() {
      try {
        const constraints = { video: { facingMode: 'environment', width: {ideal:1280}, height: {ideal:720} }, audio: false };
        const s = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = s;
        await video.play();
      } catch (err) {
        console.error('Camera error', err);
        status('camera error: ' + err.message);
      }
    }
    startCamera();

    // Canvas sizing with DPR
    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const w = canvas.clientWidth || canvas.offsetWidth;
      const h = canvas.clientHeight || canvas.offsetHeight;
      canvas.width = Math.max(1, Math.floor(w * dpr));
      canvas.height = Math.max(1, Math.floor(h * dpr));
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale drawing to CSS pixels
    }
    window.addEventListener('resize', resizeCanvas);
    // ensure canvas CSS size matches container
    function ensureCanvasCssSize() {
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      resizeCanvas();
    }
    ensureCanvasCssSize();

    // Data and rendering state
    let maxSamples = Math.max(16, parseInt(maxSamplesInput.value) || 64);
    let samples = new Float32Array(maxSamples).fill(0);
    // displayed values for smooth animation
    let displayed = new Float32Array(maxSamples).fill(0);

    maxSamplesInput.addEventListener('change', () => {
      const newMax = Math.max(8, parseInt(maxSamplesInput.value) || 64);
      if (newMax === maxSamples) return;
      const newSamples = new Float32Array(newMax);
      const newDisplayed = new Float32Array(newMax);
      // copy end of existing samples into new array so recent data stays visible
      const copyFrom = Math.max(0, samples.length - newMax);
      for (let i = 0; i < newMax; i++) {
        newSamples[i] = samples[copyFrom + i] || 0;
        newDisplayed[i] = displayed[copyFrom + i] || 0;
      }
      samples = newSamples;
      displayed = newDisplayed;
      maxSamples = newMax;
    });

    function status(msg) {
      statusEl.textContent = 'Status: ' + msg;
    }

    function pushSamples(newSamples) {
      // newSamples: array of numbers
      const n = newSamples.length;
      if (n >= samples.length) {
        // if more samples than capacity, keep only last portion
        const slice = newSamples.slice(-samples.length);
        for (let i=0;i<samples.length;i++) samples[i] = Number(slice[i]) || 0;
      } else {
        // shift left by n and append
        samples.copyWithin(0, n);
        for (let i=0;i<n;i++) samples[samples.length - n + i] = Number(newSamples[i]) || 0;
      }
    }

    function parseTextToNumbers(text) {
      const nums = [];
      const re = /[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/g;
      let m;
      while ((m = re.exec(text)) !== null) {
        nums.push(parseFloat(m[0]));
      }
      return nums;
    }

    // Polling and SSE
    let es = null;
    let poller = null;

    async function startPolling(url, intervalMs=200) {
      stopAllStreams();
      status('polling ' + url);
      poller = setInterval(async () => {
        try {
          const res = await fetch(url, {cache:'no-store'});
          if (!res.ok) { console.warn('Polling fetch not ok', res.status); status('poll error ' + res.status); return; }
          const ct = res.headers.get('content-type') || '';
          if (ct.includes('application/json')) {
            const json = await res.json();
            if (Array.isArray(json)) pushSamples(json.map(Number));
            else if (json.samples && Array.isArray(json.samples)) pushSamples(json.samples.map(Number));
            else pushSamples(parseTextToNumbers(JSON.stringify(json)));
          } else {
            const txt = await res.text();
            pushSamples(parseTextToNumbers(txt));
          }
        } catch (err) {
          console.error('poll error', err);
          status('poll error ' + err.message);
        }
      }, intervalMs);
    }

    function startSSE(sseUrl) {
      stopAllStreams();
      try {
        es = new EventSource(sseUrl, { withCredentials: false });
      } catch (err) {
        status('SSE init error: ' + err.message);
        console.error(err);
        return;
      }
      status('SSE connecting...');
      es.onopen = () => status('SSE connected');
      es.onerror = (e) => {
        console.warn('SSE error', e);
        status('SSE error (see console)');
      };
      es.onmessage = (ev) => {
        try {
          const s = ev.data.trim();
          if (!s) return;
          if (s.startsWith('[')) {
            const arr = JSON.parse(s);
            pushSamples(arr.map(Number));
          } else if (s.includes('\n')) {
            pushSamples(parseTextToNumbers(s));
          } else {
            const n = parseFloat(s);
            if (!Number.isNaN(n)) pushSamples([n]);
          }
        } catch (err) {
          console.error('SSE parse error', err);
        }
      };
    }

    function stopAllStreams() {
      if (es) { es.close(); es = null; }
      if (poller) { clearInterval(poller); poller = null; }
      disconnectBtn.disabled = true;
      connectBtn.disabled = false;
    }

    // --- New: automatic rewrite for rs.local -> localhost proxy ---
    // If the user enters a URL that targets rs.local, rewrite it to use the localhost proxy.
    // If the original looks like an SSE endpoint (contains /sse or eventsource) we rewrite to /sse proxy,
    // otherwise we rewrite to /proxy.
    function isRsLocalUrl(u) {
      try {
        const parsed = new URL(u);
        return parsed.hostname.toLowerCase() === 'rs.local';
      } catch (e) {
        return false;
      }
    }
    function rewriteRsLocalToLocalProxy(u) {
      if (!u) return u;
      // If already pointed at localhost:3000, don't rewrite again
      try {
        const parsed = new URL(u);
        if (parsed.hostname === 'localhost' && (parsed.port === '3000' || parsed.port === '')) return u;
      } catch (e) {
        // ignore
      }

      if (isRsLocalUrl(u)) {
        const wantsSse = /\/sse\b|eventsource/i.test(u);
        const proxyBase = wantsSse ? 'http://localhost:3000/sse?url=' : 'http://localhost:3000/proxy?url=';
        return proxyBase + encodeURIComponent(u);
      }
      return u;
    }
    // -----------------------------------------------------------

    connectBtn.addEventListener('click', () => {
      let src = sourceInput.value.trim();
      maxSamples = Math.max(8, parseInt(maxSamplesInput.value) || 64);
      if (!src) { status('no source'); return; }

      // Apply automatic rewrite for rs.local
      const rewritten = rewriteRsLocalToLocalProxy(src);
      if (rewritten !== src) {
        status('rewrote rs.local -> localhost proxy');
        console.info('rewrote', src, '->', rewritten);
        src = rewritten;
      }

      if (src.startsWith('http') && (src.toLowerCase().includes('/sse') || src.toLowerCase().includes('eventsource'))) {
        startSSE(src);
      } else if (src.startsWith('http') && src.indexOf('://') !== -1 && src.indexOf('localhost') !== -1) {
        if (src.includes('/sse')) startSSE(src);
        else startPolling(src, Math.max(50, parseInt(pollInput.value) || 200));
      } else {
        if (src.startsWith('sse://')) {
          startSSE(src.replace(/^sse:\/\//, 'http://'));
        } else {
          startPolling(src, Math.max(50, parseInt(pollInput.value) || 200));
        }
      }
      disconnectBtn.disabled = false;
      connectBtn.disabled = true;
    });

    disconnectBtn.addEventListener('click', () => {
      stopAllStreams();
      status('disconnected');
    });

    sourceInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') connectBtn.click();
    });

    // Initial filler data so chart isn't empty
    for (let i=0;i<samples.length;i++) samples[i] = Math.abs(Math.sin(i/6) * 0.05 + Math.random() * 0.02);

    // Drawing loop: typical animated bar chart
    function draw() {
      requestAnimationFrame(draw);
      resizeCanvas(); // ensures correct size when layout changes
      const width = canvas.clientWidth || canvas.width;
      const height = canvas.clientHeight || canvas.height;
      // Clear (use semi-transparent fill for slight trail effect)
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Parameters
      const padding = 24;
      const innerW = (canvas.width / (window.devicePixelRatio || 1)) - padding * 2;
      const innerH = (canvas.height / (window.devicePixelRatio || 1)) - padding * 2;
      const barCount = samples.length;
      const gap = Math.max(2, Math.floor(innerW / barCount * 0.12));
      const barWidth = Math.max(2, (innerW - (barCount - 1) * gap) / barCount);

      // Smooth displayed values toward target samples
      const smoothing = 0.12; // 0 => no smoothing, 1 => instant
      for (let i=0;i<barCount;i++) {
        const target = Math.abs(Number(samples[i]) || 0);
        displayed[i] += (target - displayed[i]) * smoothing;
      }

      // Find dynamic max for nicer scaling (avoid zero)
      let maxVal = 0.0001;
      for (let i=0;i<barCount;i++) if (displayed[i] > maxVal) maxVal = displayed[i];
      // Add small headroom
      maxVal *= 1.2;

      // Draw bars
      for (let i=0;i<barCount;i++) {
        const x = padding + i * (barWidth + gap);
        const norm = Math.min(1, displayed[i] / maxVal);
        const h = norm * innerH;
        const y = padding + (innerH - h);

        // Color gradient across bars (left-to-right)
        const hue = (i / Math.max(1, barCount)) * 220; // 0..220
        ctx.fillStyle = `hsl(${hue}, 85%, ${30 + norm * 40}%)`;
        // Drop shadow / glow
        ctx.shadowColor = `hsla(${hue}, 85%, 55%, ${0.18 + norm*0.3})`;
        ctx.shadowBlur = 12 * Math.min(1, 0.3 + norm*2);
        ctx.fillRect(x, y, barWidth, h);

        // Clear shadow for outlines/text
        ctx.shadowBlur = 0;
        // bar outline (subtle)
        ctx.strokeStyle = 'rgba(0,0,0,0.25)';
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 0.5, y + 0.5, barWidth - 1, h - 1);
      }

      // Draw baseline and labels
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.font = '12px system-ui,Segoe UI,Roboto,Helvetica,Arial';
      ctx.textBaseline = 'top';
      // Show max value label
      ctx.fillText('max: ' + maxVal.toFixed(3), padding, padding - 16);
      // Sample count
      ctx.fillText('bars: ' + barCount, padding + 120, padding - 16);
    }

    // Start draw loop
    draw();

    // Expose for debugging
    window.__overlay = { pushSamples, startSSE, startPolling, stopAllStreams, samples, displayed };
  })();
  </script>
</body>
</html>
