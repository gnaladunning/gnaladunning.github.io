<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Political Disenfranchisement AR</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      touch-action: none;
      background: #000;
    }
    #politicalCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      pointer-events: none;
      background: #000;
      object-fit: cover;
      display: block;
    }
    #videoElement {
      display: none;
    }
  </style>
</head>
<body>
  <video id="videoElement" autoplay playsinline muted></video>
  <canvas id="politicalCanvas"></canvas>
  <script>
    const politicalCanvas = document.getElementById('politicalCanvas');
    const video = document.getElementById('videoElement');
    const ctx = politicalCanvas.getContext('2d');

    // AR Cluster settings (slower and longer for readability)
    const WORD_INTERVAL = 100000;      // ms per text (1.5 min)
    const FADE_DURATION = 40000;      // ms for fade transition (40 sec)
    const APPEAR_DURATION = 80000;    // ms for new cluster/text fade-in
    const DISAPPEAR_DURATION = 40000; // ms for cluster/text fade-out
    const MAX_CLUSTERS = 2;

    // 100 brief, natural, conversational movie/TV descriptions
    const popCultureSnippets = [
      "a crew heads into deep space, hoping to find new worlds but ends up facing strange creatures",
      "a group fights against a controlling regime in a bleak future, risking it all for freedom",
      "teens deal with crushes, drama, and growing up in a high school where everything feels intense",
      "a detective digs into a tangled crime, finding secrets nobody wants uncovered",
      "a family struggles to keep their restaurant afloat while dealing with hilarious mishaps",
      "friends get together for weekly trivia night, but relationships complicate everything",
      "a time traveler tries to fix the past but keeps creating new problems in the present",
      "a lawyer defends unlikely clients, uncovering truth in every case",
      "a small town faces big changes when a mysterious stranger arrives",
      "a superhero tries balancing saving the world and a normal social life",
      "a chef competes in a high-pressure cooking contest, hoping to win it all",
      "a scientist makes a discovery that could change humanity, but faces ethical dilemmas",
      "a musician tours the country, struggling with fame, family, and creative blocks",
      "a teacher inspires students in a tough school, showing them hope",
      "two rivals battle for control of a powerful artifact that could reshape the world",
      "a robot learns about emotions while trying to fit in with humans",
      "a sports team overcomes setbacks to reach the championship",
      "siblings inherit a haunted house and must solve its mysteries",
      "a spy infiltrates an enemy group, risking exposure at every turn",
      "a couple goes on a road trip, facing unexpected adventures and challenges",
      "a community bands together to fight corporate greed threatening their homes",
      "an artist tries to finish their masterpiece before a looming deadline",
      "a doctor treats unusual cases in a fast-paced city hospital",
      "a rookie cop partners with a veteran to solve a puzzling crime",
      "a politician campaigns for change but faces tough opposition",
      "a magical creature befriends a lonely child, shaping both their destinies",
      "a group of hackers expose corruption, becoming targets themselves",
      "a young inventor builds something incredible that draws global attention",
      "neighbors feud until a crisis forces them to work together",
      "a survivor navigates a world after a catastrophic event",
      "a journalist uncovers a scandal, risking their career to reveal the truth",
      "a college student juggles studies, romance, and a secret double life",
      "a dancer trains for a life-changing audition, facing setbacks",
      "a parent tries to reconnect with their teenager after a falling-out",
      "a group gets stuck in an elevator, revealing secrets and forming bonds",
      "a dog helps its owner through life's ups and downs",
      "a fashion designer launches a new line and faces industry challenges",
      "a gamer becomes an unexpected champion in a global tournament",
      "a baker opens a new shop, hoping to win over the community",
      "a group of strangers must solve riddles to escape a locked room",
      "a pilot flies a risky rescue mission in dangerous weather",
      "a historian discovers old letters that change how people see the past",
      "a group organizes a charity event, building friendships along the way",
      "a scientist and explorer team up to save an endangered species",
      "an astronaut faces unexpected challenges during a spacewalk",
      "a festival brings the town together in celebration and conflict",
      "an actor auditions for a dream role, confronting self-doubt",
      "a retiree starts a new career, surprising everyone",
      "a rival band challenges the town's favorite musicians at a contest",
      "a writer struggles with writer's block and creative inspiration",
      "a child builds a treehouse that becomes a neighborhood hub",
      "a chef searches for rare ingredients to create a special dish",
      "a prankster pulls off elaborate stunts, but faces consequences",
      "a couple plans a wedding, navigating family drama",
      "three siblings compete for a family heirloom in funny ways",
      "a volunteer helps rebuild homes after a disaster",
      "a mentor guides a young prodigy through tough times",
      "a singer tries to win a talent show with an original song",
      "a retired detective gets pulled back into a cold case",
      "a parent and child switch bodies and gain new perspectives",
      "a teacher organizes a school play that brings the community together",
      "a group of friends travel abroad, encountering culture shock",
      "a lost kitten finds its way home with help from new friends",
      "an inventor creates a gadget that changes daily life",
      "a young leader rallies people for an important cause",
      "a couple struggles to balance work and personal life",
      "a magician uncovers a real mystery behind their tricks",
      "a team restores an old building, uncovering its history",
      "a prodigy faces pressure to meet high expectations",
      "a neighbor helps solve a local mystery",
      "a group starts a band and dreams of stardom",
      "an athlete overcomes injury to achieve a personal best",
      "a student investigates a campus legend",
      "a group of artists collaborate on a mural that transforms their city",
      "a volunteer teaches music in an underserved area",
      "a family reunites after years apart",
      "a police officer helps a troubled youth find their path",
      "a chef mentors young cooks in a competitive kitchen",
      "a scientist races to solve a global crisis",
      "a community garden helps neighbors connect",
      "a group of hikers gets lost and must rely on each other",
      "a new mayor faces unexpected challenges in office",
      "a couple adopts a rescue animal and learns new lessons",
      "a musician writes a song that inspires social change",
      "a young activist organizes a protest for justice",
      "a teacher helps a student believe in themselves",
      "a startup founder pitches an idea to skeptical investors",
      "a filmmaker documents a town's unique history",
      "a group of kids solve puzzles to win a treasure hunt",
      "a nurse comforts patients in a busy hospital",
      "a team invents a device to clean up pollution",
      "a parent volunteers at a local shelter",
      "a librarian helps people discover new worlds through books",
      "a coach inspires a team to never give up",
      "a scientist discovers a new species",
      "a young artist gets their first gallery show",
      "a family faces a tough move but finds hope in a new place",
      "a group of neighbors plan a block party",
      "a student organizes a fundraiser for a good cause",
      "newsroom staff race to cover breaking stories while competing for scoops"
    ];

    function pickSnippets(count) {
      // Pick 'count' unique random snippets from the array
      const arr = [...popCultureSnippets];
      const selected = [];
      while (selected.length < count && arr.length > 0) {
        const idx = Math.floor(Math.random() * arr.length);
        selected.push(arr[idx]);
        arr.splice(idx, 1);
      }
      return selected;
    }

    // Cluster management with fade-in/fade-out
    let clusterStates = [];
    let prevClusterCenters = [];
    let lastTextTrigger = Date.now();

    function isWideRangeColor(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      let max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = ((g - b) / d + (g < b ? 6 : 0)); break;
          case g: h = ((b - r) / d + 2); break;
          case b: h = ((r - g) / d + 4); break;
        }
        h /= 6;
      }
      const greenish = h >= 0.2 && h <= 0.45;
      const yellowish = h >= 0.12 && h < 0.2;
      const cyanish = h > 0.45 && h < 0.55;
      const bright = l > 0.28;
      const colorful = s > 0.35;
      return (greenish || yellowish || cyanish) && bright && colorful;
    }

    function clusterColorPixels(data, width, height) {
      const visited = new Uint8Array(width * height);
      const clusters = [];
      const pixelIndex = (x, y) => (y * width + x) * 4;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          if (visited[idx]) continue;
          const i = pixelIndex(x, y);
          if (isWideRangeColor(data[i], data[i + 1], data[i + 2])) {
            const queue = [[x, y]];
            const cluster = [];
            let minX = x, maxX = x, minY = y, maxY = y;
            visited[idx] = 1;
            while (queue.length) {
              const [cx, cy] = queue.pop();
              cluster.push([cx, cy]);
              minX = Math.min(minX, cx); maxX = Math.max(maxX, cx);
              minY = Math.min(minY, cy); maxY = Math.max(maxY, cy);
              for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                  const nx = cx + dx, ny = cy + dy;
                  if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                  const nidx = ny * width + nx;
                  if (!visited[nidx]) {
                    const ni = pixelIndex(nx, ny);
                    if (isWideRangeColor(data[ni], data[ni + 1], data[ni + 2])) {
                      queue.push([nx, ny]);
                      visited[nidx] = 1;
                    }
                  }
                }
              }
            }
            if (
              cluster.length > 18 &&
              minX > 0 && maxX < width - 1 &&
              minY > 0 && maxY < height - 1
            ) {
              clusters.push(cluster);
              if (clusters.length >= MAX_CLUSTERS) return clusters;
            }
          }
        }
      }
      return clusters;
    }

    function getClusterCenter(cluster) {
      let sumX = 0, sumY = 0;
      for (const [x, y] of cluster) {
        sumX += x;
        sumY += y;
      }
      return [sumX / cluster.length, sumY / cluster.length];
    }

    function getClusterSize(cluster) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const [x, y] of cluster) {
        minX = Math.min(minX, x); maxX = Math.max(maxX, x);
        minY = Math.min(minY, y); maxY = Math.max(maxY, y);
      }
      return Math.sqrt((maxX - minX) * (maxY - minY) + cluster.length);
    }

    function pickSnippet(existing = []) {
      // Pick a snippet not in use for current clusters
      let available = popCultureSnippets.filter(s => !existing.includes(s));
      if (available.length === 0) return popCultureSnippets[Math.floor(Math.random() * popCultureSnippets.length)];
      return available[Math.floor(Math.random() * available.length)];
    }

    function updateClusters(currentCenters, currentSizes) {
      // Assign snippets so they do not overlap (no duplicates on screen)
      let newStates = [];
      let matched = new Set();
      let usedSnippets = clusterStates.map(c => c.snippet);

      for (let i = 0; i < currentCenters.length; i++) {
        let center = currentCenters[i];
        let size = currentSizes[i];
        let foundIdx = -1, minDist = Infinity;
        for (let j = 0; j < clusterStates.length; j++) {
          let prev = clusterStates[j];
          if (prev.status === "disappearing") continue;
          let dist = Math.hypot(center[0] - prev.center[0], center[1] - prev.center[1]);
          if (dist < 60 && dist < minDist && !matched.has(j)) {
            minDist = dist;
            foundIdx = j;
          }
        }
        if (foundIdx !== -1) {
          let prev = clusterStates[foundIdx];
          newStates.push({
            ...prev,
            center,
            size,
            appearStart: prev.appearStart,
            status: "visible",
            disappearStart: null,
            lastUpdate: Date.now()
          });
          matched.add(foundIdx);
        } else {
          let snippet = pickSnippet(usedSnippets.concat(newStates.map(c => c.snippet)));
          newStates.push({
            center,
            size,
            snippet,
            nextSnippet: snippet,
            textFade: 1,
            textLastChange: Date.now(),
            appearStart: Date.now(),
            status: "appearing",
            disappearStart: null,
            depth: Math.random(),
            lastUpdate: Date.now()
          });
        }
      }

      // Existing clusters not matched: fade out
      for (let j = 0; j < clusterStates.length; j++) {
        if (matched.has(j)) continue;
        let prev = clusterStates[j];
        if (prev.status === "disappearing" && prev.disappearStart && Date.now() - prev.disappearStart < DISAPPEAR_DURATION) {
          newStates.push(prev);
        } else if (prev.status !== "disappearing") {
          newStates.push({
            ...prev,
            status: "disappearing",
            disappearStart: Date.now()
          });
        }
      }
      clusterStates = newStates.slice(0, MAX_CLUSTERS);

      // Ensure non-overlapping placement by shifting clusters if needed
      if (clusterStates.length === 2) {
        let c1 = clusterStates[0], c2 = clusterStates[1];
        let normSize1 = Math.max(1, Math.min(1.0, (c1.size - 120) / (politicalCanvas.width * 0.13)));
        let normSize2 = Math.max(1, Math.min(1.0, (c2.size - 120) / (politicalCanvas.width * 0.13)));
        let fontSize1 = Math.round(28 + normSize1 * 62 * (1 - (c1.depth || 0) * 0.5));
        let fontSize2 = Math.round(28 + normSize2 * 62 * (1 - (c2.depth || 0) * 0.5));

        // Minimum distance to avoid overlap: fontSize plus some extra
        let minDist = 60 + Math.max(fontSize1, fontSize2);
        if ((Math.sqrt(
              Math.pow(c1.center[0] - c2.center[0], 2) +
              Math.pow(c1.center[1] - c2.center[1], 2)
            ) < minDist)) {
          // Push clusters apart horizontally
          if (c1.center[0] < c2.center[0]) {
            c1.center[0] -= minDist / 2;
            c2.center[0] += minDist / 2;
          } else {
            c1.center[0] += minDist / 2;
            c2.center[0] -= minDist / 2;
          }
        }
      }
    }

    function updateTextTransitions() {
      const now = Date.now();
      for (let cluster of clusterStates) {
        if (cluster.status === "appearing" && cluster.appearStart) {
          let t = (now - cluster.appearStart) / APPEAR_DURATION;
          cluster.appearProgress = Math.min(1, t);
          if (cluster.appearProgress >= 1) {
            cluster.status = "visible";
            cluster.appearStart = null;
            cluster.appearProgress = 1;
          }
        }
        if (cluster.status === "disappearing" && cluster.disappearStart) {
          let t = (now - cluster.disappearStart) / DISAPPEAR_DURATION;
          cluster.disappearProgress = Math.min(1, t);
        }
        if (cluster.textFade < 1) {
          let t = (now - cluster.textLastChange) / FADE_DURATION;
          cluster.textFade = Math.min(1, t);
          if (cluster.textFade >= 1) {
            cluster.snippet = cluster.nextSnippet;
          }
        }
      }
    }

    function triggerTextChanges() {
      let used = clusterStates.map(c => c.snippet);
      for (let cluster of clusterStates) {
        let next = pickSnippet(used);
        cluster.nextSnippet = next;
        cluster.textFade = 0;
        cluster.textLastChange = Date.now();
        cluster.depth = Math.random();
        used.push(next);
      }
    }

    function getSplinePoints(points, tension = 0.5, numOfSeg = 18) {
      if (points.length < 2) return points;
      let result = [];
      for (let i = 0; i < points.length - 1; i++) {
        let p0 = points[i === 0 ? i : i - 1];
        let p1 = points[i];
        let p2 = points[i + 1];
        let p3 = points[i + 2 < points.length ? i + 2 : i + 1];
        for (let t = 0; t < numOfSeg; t++) {
          let st = t / numOfSeg;
          let x = catmullRom(p0[0], p1[0], p2[0], p3[0], st, tension);
          let y = catmullRom(p0[1], p1[1], p2[1], p3[1], st, tension);
          result.push([x, y]);
        }
      }
      return result;
    }

    function catmullRom(p0, p1, p2, p3, t, tension) {
      let v0 = (p2 - p0) * tension;
      let v1 = (p3 - p1) * tension;
      return (2 * p1 - 2 * p2 + v0 + v1) * t * t * t
           + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t * t
           + v0 * t
           + p1;
    }

    function drawColorOverlays(ctx, clusters) {
      updateTextTransitions();
      ctx.save();

      let centers = clusters.filter(c => c.status !== "disappearing" || (c.status === "disappearing" && c.disappearProgress < 1)).map(c => c.center);
      if (centers.length >= 2) {
        let spline = getSplinePoints(centers, 0.5, 18);
        ctx.beginPath();
        ctx.strokeStyle = "#FF4141";
        ctx.lineWidth = 2.5;
        ctx.shadowColor = "#FF4141";
        ctx.shadowBlur = 16;
        for (let i = 0; i < spline.length - 1; i++) {
          let [x1, y1] = spline[i];
          let [x2, y2] = spline[i + 1];
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
        }
        let minAlpha = 1.0;
        for (let c of clusters) {
          let alpha = 1.0;
          if (c.status === "appearing") alpha = c.appearProgress || 0;
          if (c.status === "disappearing") alpha = 1 - (c.disappearProgress || 0);
          minAlpha = Math.min(minAlpha, alpha);
        }
        ctx.globalAlpha = 0.38 + minAlpha * 0.3;
        ctx.stroke();
        ctx.globalAlpha = 1.0;
      }

      // Multi-line text at cluster centers
      for (let i = 0; i < clusters.length; i++) {
        let cluster = clusters[i];
        let [x, y] = cluster.center;
        let z = cluster.depth || 0;
        let size = cluster.size;

        // Font size grows with size (camera closer = larger color patch)
        let minFont = 28, maxFont = 90;
        let norm = Math.max(0, Math.min(1, (size - 120) / (politicalCanvas.width * 0.13)));
        let fontSize = Math.round(minFont + norm * (maxFont - minFont) * (1 - z * 0.5));
        cluster.fontSize = fontSize;

        let minAlpha = 0.56, maxAlpha = 0.96;
        let alpha = maxAlpha - z * (maxAlpha - minAlpha);

        let appearAlpha = 1.0;
        if (cluster.status === "appearing") appearAlpha = cluster.appearProgress || 0;
        if (cluster.status === "disappearing") appearAlpha = 1 - (cluster.disappearProgress || 0);
        alpha *= appearAlpha;

        let snippet, snippetAlpha;
        if (cluster.textFade < 1) {
          snippet = cluster.nextSnippet;
          snippetAlpha = alpha * cluster.textFade * 0.93 + 0.07 * alpha;
        } else {
          snippet = cluster.snippet;
          snippetAlpha = alpha;
        }

        snippetAlpha = Math.max(0.17, snippetAlpha);

        ctx.save();
        ctx.translate(x, y);
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "#FF4141";
        ctx.shadowBlur = 23;
        ctx.globalAlpha = snippetAlpha;
        ctx.fillStyle = "#FF4141";

        // Draw multi-line text (no sentence format, lower case)
        let lines = snippet.split('\n');
        let lineHeight = fontSize * 1.28;
        let baseY = -((lines.length - 1) * lineHeight) / 2;
        for (let li = 0; li < lines.length; li++) {
          ctx.fillText(lines[li], 0, baseY + li * lineHeight);
        }

        ctx.restore();
      }
      ctx.restore();
    }

    function draw() {
      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        if (politicalCanvas.width !== video.videoWidth || politicalCanvas.height !== video.videoHeight) {
          politicalCanvas.width = video.videoWidth;
          politicalCanvas.height = video.videoHeight;
        }
        ctx.filter = "blur(1.5px) brightness(1.18) contrast(1.18)";
        ctx.drawImage(video, 0, 0, politicalCanvas.width, politicalCanvas.height);
        ctx.filter = "none";
        let frame = ctx.getImageData(0, 0, politicalCanvas.width, politicalCanvas.height);
        let data = frame.data;
        let clusters = clusterColorPixels(data, politicalCanvas.width, politicalCanvas.height);
        let clusterCenters = clusters.map(getClusterCenter);
        let clusterAreaSizes = clusters.map(getClusterSize);

        updateClusters(clusterCenters, clusterAreaSizes);

        let centersChanged = false;
        if (prevClusterCenters.length !== clusterCenters.length) {
          centersChanged = true;
        } else {
          for (let i = 0; i < clusterCenters.length; i++) {
            if (
              Math.abs(clusterCenters[i][0] - (prevClusterCenters[i]?.[0] || 0)) > 80 ||
              Math.abs(clusterCenters[i][1] - (prevClusterCenters[i]?.[1] || 0)) > 80
            ) {
              centersChanged = true;
              break;
            }
          }
        }
        prevClusterCenters = clusterCenters.slice();

        if (Date.now() - lastTextTrigger >= WORD_INTERVAL) {
          triggerTextChanges();
          lastTextTrigger = Date.now();
        }

        drawColorOverlays(ctx, clusterStates);
      }
      requestAnimationFrame(draw);
    }

    // Initialize with two random snippets at startup
    function initializeClusters() {
      const selectedSnippets = pickSnippets(MAX_CLUSTERS);
      clusterStates = [];
      for (let i = 0; i < MAX_CLUSTERS; i++) {
        clusterStates.push({
          center: [0, 0],
          size: 150,
          snippet: selectedSnippets[i],
          nextSnippet: selectedSnippets[i],
          textFade: 1,
          textLastChange: Date.now(),
          appearStart: Date.now(),
          status: "appearing",
          disappearStart: null,
          depth: Math.random(),
          lastUpdate: Date.now()
        });
      }
    }

    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false })
      .then(stream => {
        video.srcObject = stream;
        video.play();
        video.addEventListener('loadedmetadata', () => {
          politicalCanvas.width = video.videoWidth;
          politicalCanvas.height = video.videoHeight;
          initializeClusters();
          draw();
        });
      })
      .catch(() => {
        alert('Camera access denied or unavailable.');
      });

    window.addEventListener('resize', () => {
      politicalCanvas.width = window.innerWidth;
      politicalCanvas.height = window.innerHeight;
    });

    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        politicalCanvas.width = window.innerWidth;
        politicalCanvas.height = window.innerHeight;
      }, 500);
    });
  </script>
</body>
</html>
