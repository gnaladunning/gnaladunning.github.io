<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Compositional Geometry AR Analyzer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no,viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <style>
    html, body {
      margin:0; padding:0; width:100vw; height:100vh; background:#181818; color:#fff;
      overflow:hidden; overscroll-behavior:none; font-family:sans-serif;
    }
    #cameraFeed {
      position:fixed; left:0; top:0; width:100vw; height:100vh; object-fit:cover; z-index:0; background:#000;
    }
    #overlayCanvas {
      position:fixed; left:0; top:0; width:100vw; height:100vh; z-index:1; pointer-events:none;
    }
    .controls {
      position: absolute; right: 1em; top: 1em; z-index: 2; background:rgba(30,30,30,0.80);
      border-radius:8px; padding:.7em 1em; font-size:1em;
    }
    .controls label { display:block; margin-bottom:.3em; }
    #instructions {
      background:rgba(0,0,0,0.8); color:#fff; max-width:430px;
      margin:.6em auto; border-radius: 8px; padding: 11px; font-size:.99em;
      z-index: 3; position:relative; text-align:center;
    }
    #loading {
      position:fixed; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0.7);
      z-index: 100; color:#fff; display:flex; align-items:center; justify-content:center;
      font-size:1.3em; display:none;
    }
  </style>
</head>
<body>
  <div id="instructions">
    <b>Web AR: Compositional Geometry Analyzer</b>
    <ol style="padding-left:1.2em; text-align:left;">
      <li>Allow access to your camera.</li>
      <li>Point your device at images, artworks, photography, or everyday scenes.</li>
      <li>
        <b>Features:</b>
        <ul>
          <li><b>Geometric Feature Extraction:</b> Identifies lines, quadrilaterals, triangles, ovals, circles, and their spatial arrangement using shape analysis.</li>
          <li><b>Compositional Rule Detection:</b> Detects rule of thirds, golden section, and central axis balance by quantifying placement and ratios of detected elements.</li>
          <li><b>Symmetry and Balance Analysis:</b> Computes Gestalt-based symmetry and "Assessment of Preference for Balance" (APB) metrics, including visual center of gravity.</li>
          <li><b>Structural Stability Metrics:</b> Evaluates the equilibrium and robustness of visual arrangements.</li>
        </ul>
      </li>
    </ol>
    <div style="margin-top:.7em; font-size:.92em;color:#cfa;">
      All processing is on-device in your browser with OpenCV.js. For best results, use Safari (iOS) or Chrome/Edge (Android).
    </div>
  </div>
  <div id="loading">Loading computer vision library&hellip;</div>
  <div class="controls">
    <label><input type="checkbox" id="linesChk" checked> Lines</label>
    <label><input type="checkbox" id="shapesChk" checked> Shapes (Quads/Ovals/Triangles/Circles)</label>
    <label><input type="checkbox" id="compositionChk" checked> Compositional Rules</label>
    <label><input type="checkbox" id="symmetryChk"> Symmetry/Balance</label>
    <label><input type="checkbox" id="stabilityChk"> Structural Stability</label>
  </div>
  <video id="cameraFeed" autoplay playsinline muted></video>
  <canvas id="overlayCanvas"></canvas>
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
  <script>
    const video = document.getElementById('cameraFeed');
    const canvas = document.getElementById('overlayCanvas');
    const ctx = canvas.getContext('2d');
    const loadingDiv = document.getElementById('loading');

    // Overlay feature toggles
    const overlays = {
      lines: true,
      shapes: true,
      composition: true,
      symmetry: false,
      stability: false
    };
    document.getElementById('linesChk').onchange = function(){ overlays.lines = this.checked; };
    document.getElementById('shapesChk').onchange = function(){ overlays.shapes = this.checked; };
    document.getElementById('compositionChk').onchange = function(){ overlays.composition = this.checked; };
    document.getElementById('symmetryChk').onchange = function(){ overlays.symmetry = this.checked; };
    document.getElementById('stabilityChk').onchange = function(){ overlays.stability = this.checked; };

    function resize() {
      const w = window.innerWidth, h = window.innerHeight;
      video.style.width = w+"px";
      video.style.height = h+"px";
      canvas.width = w;
      canvas.height = h;
    }
    window.addEventListener('resize', resize);
    window.addEventListener('orientationchange', resize);
    window.addEventListener('DOMContentLoaded', resize);

    // Camera setup
    async function startCamera(){
      try {
        if (!navigator.mediaDevices) throw new Error("No camera support");
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
        video.srcObject = stream;
        await video.play();
        document.getElementById('instructions').style.display = "none";
      } catch(e) {
        alert("Camera error: " + (e.message||e));
      }
    }
    startCamera();

    // OpenCV setup
    let cvReady = false;
    function onOpenCvReady() {
      loadingDiv.style.display = 'none';
      cvReady = true;
      if (video.readyState >= 2) mainLoop();
      else video.onloadeddata = mainLoop;
    }

    function ensureCVLoaded() {
      if (!cvReady) loadingDiv.style.display = '';
      else loadingDiv.style.display = 'none';
    }

    // --- Geometric/Compositional Analysis Utilities ---
    function drawRuleOfThirds(ctx, w, h) {
      ctx.save();
      ctx.strokeStyle = "#ffd800";
      ctx.lineWidth = 1.6;
      ctx.setLineDash([5,5]);
      for(let i=1; i<=2; ++i) {
        ctx.beginPath();
        ctx.moveTo(w/3*i, 0);
        ctx.lineTo(w/3*i, h);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, h/3*i);
        ctx.lineTo(w, h/3*i);
        ctx.stroke();
      }
      ctx.setLineDash([]);
      ctx.restore();
    }
    function drawGoldenSection(ctx, w, h) {
      const phi = 0.618;
      ctx.save();
      ctx.strokeStyle = "#ff8e4e";
      ctx.lineWidth = 1.25;
      ctx.setLineDash([8,6]);
      // Vertical sections
      ctx.beginPath();
      ctx.moveTo(w*phi, 0); ctx.lineTo(w*phi, h); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(w*(1-phi), 0); ctx.lineTo(w*(1-phi), h); ctx.stroke();
      // Horizontal sections
      ctx.beginPath();
      ctx.moveTo(0, h*phi); ctx.lineTo(w, h*phi); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, h*(1-phi)); ctx.lineTo(w, h*(1-phi)); ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }
    function drawCentralAxis(ctx, w, h) {
      ctx.save();
      ctx.strokeStyle = "#56F3F1"; ctx.lineWidth = 1.1; ctx.setLineDash([5,5]);
      ctx.beginPath(); ctx.moveTo(w/2,0); ctx.lineTo(w/2,h); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,h/2); ctx.lineTo(w, h/2); ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    // Detect center of gravity (simple mean of contours' points)
    function computeCenterOfGravity(contours, w, h) {
      let sx = 0, sy = 0, n = 0;
      for (let i=0; i < contours.size(); ++i) {
        let c = contours.get(i);
        for (let j=0; j < c.rows; ++j) {
          let pt = c.data32S.subarray(j*2, j*2+2);
          sx += pt[0] * w / 640;
          sy += pt[1] * h / 480;
          n++;
        }
      }
      if (n === 0) return null;
      return [sx/n, sy/n];
    }

    // --- MAIN CV Loop ---
    function mainLoop() {
      ensureCVLoaded();
      if (!(video.videoWidth && video.videoHeight && cvReady)) {
        setTimeout(mainLoop, 100);
        return;
      }
      resize();

      const vw = canvas.width, vh = canvas.height;
      let src = new cv.Mat(vh, vw, cv.CV_8UC4);
      let gray = new cv.Mat();
      let edges = new cv.Mat();
      let lines = new cv.Mat();
      let hierarchy = new cv.Mat();
      let contours = new cv.MatVector();
      let circles = new cv.Mat();

      function processFrame() {
        ctx.clearRect(0,0,vw,vh);

        // 1. Draw compositional guides if enabled
        if (overlays.composition) {
          drawRuleOfThirds(ctx, vw, vh);
          drawGoldenSection(ctx, vw, vh);
          drawCentralAxis(ctx, vw, vh);
        }
        // 2. Predict symmetry/balance axes if enabled (hint: Guides only; not full symmetry scoring)
        if (overlays.symmetry) {
          ctx.save();
          ctx.strokeStyle="#10d86d"; ctx.lineWidth=1.3;
          ctx.setLineDash([2,2]);
          ctx.beginPath(); ctx.arc(vw/2, vh/2, Math.min(vw,vh)/3, 0, 2*Math.PI); ctx.stroke();
          ctx.restore();
        }

        // 3. Get frame from video input
        let offCanvas = document.createElement('canvas');
        offCanvas.width = vw; offCanvas.height = vh;
        let offCtx = offCanvas.getContext('2d');
        offCtx.drawImage(video, 0, 0, vw, vh);
        let imageData = offCtx.getImageData(0,0,vw,vh);
        src.data.set(imageData.data);

        // 4. Gray, Edge, FindLines, FindContours
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        cv.Canny(gray, edges, 60, 140, 3, false);
        cv.HoughLinesP(edges, lines, 1, Math.PI/180, 70, 60, 10);
        cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        // 5. Draw detected lines
        if (overlays.lines) {
          ctx.save();
          ctx.globalAlpha = 0.80;
          ctx.strokeStyle = "#FFD700";
          ctx.lineWidth = 4;
          ctx.lineJoin = "round";
          ctx.lineCap = "round";
          for (let i = 0; i < lines.rows; ++i) {
            let l = lines.data32S.subarray(i*4, i*4+4);
            let x1 = l[0]*vw/edges.cols, y1 = l[1]*vh/edges.rows;
            let x2 = l[2]*vw/edges.cols, y2 = l[3]*vh/edges.rows;
            ctx.beginPath();
            ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
            ctx.stroke();
          }
          ctx.restore();
        }

        // 6. Detect and draw contours for quads/triangles/ovals/circles
        if (overlays.shapes) {
          ctx.save();
          ctx.strokeStyle = "#4EF1FF"; ctx.lineWidth = 3.2;
          for (let i=0; i < contours.size(); ++i) {
            let c = contours.get(i);
            let approx = new cv.Mat();
            cv.approxPolyDP(c, approx, 0.03*cv.arcLength(c, true), true);
            let n=approx.rows;
            let pts=[];
            for(let j=0;j<n;++j){
              let pt = approx.data32S.subarray(j*2, j*2+2);
              pts.push([pt[0]*vw/edges.cols, pt[1]*vh/edges.rows]);
            }
            ctx.beginPath();
            pts.forEach((p,j)=>j===0?ctx.moveTo(p[0],p[1]):ctx.lineTo(p[0],p[1]));
            if (n>=3) ctx.closePath();
            ctx.stroke();
            // highlight by type: quadrilateral, triangle, etc.
            if(n===3){ctx.fillStyle="#fff6";ctx.fill();}
            if(n===4){ctx.fillStyle="#ff06";ctx.fill();}
            approx.delete();
          }
          ctx.restore();

          // Circles (Hough)
          let blur = new cv.Mat();
          cv.medianBlur(gray, blur, 7);
          cv.HoughCircles(blur, circles, cv.HOUGH_GRADIENT, 1, 80, 130, 35, 15, Math.min(vw,vh)/2);
          ctx.save();
          ctx.globalAlpha = 1.0;
          ctx.strokeStyle = "#18D6FF";
          ctx.lineWidth = 4;
          for (let i=0; i<circles.cols; ++i) {
            let x = circles.data32F[i*3], y = circles.data32F[i*3+1], r=circles.data32F[i*3+2];
            ctx.beginPath();
            ctx.ellipse(x*vw/gray.cols, y*vh/gray.rows, r*vw/gray.cols, r*vh/gray.rows, 0, 0, 2*Math.PI);
            ctx.stroke();
          }
          ctx.restore();
          blur.delete();
        }

        // 7. Display balance (center of gravity overlay)
        if (overlays.symmetry || overlays.stability) {
          let cog = computeCenterOfGravity(contours, vw, vh);
          if (cog) {
            ctx.save();
            ctx.globalAlpha = .8;
            ctx.beginPath();
            ctx.fillStyle = overlays.stability ? "#ec1" : "#5cf";
            ctx.arc(cog[0], cog[1], 13, 0, 2*Math.PI);
            ctx.fill();
            ctx.font = "bold 13px sans-serif";
            ctx.fillStyle = "#181818";
            ctx.fillText("âˆ‘", cog[0]-5, cog[1]+5);
            ctx.restore();
          }
        }
      }

      // UI frame loop
      function animationFrameLoop() {
        if (video.readyState >= 2 && cvReady) processFrame();
        requestAnimationFrame(animationFrameLoop);
      }
      animationFrameLoop();
    }
  </script>
</body>
</html>
