<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Political Disenfranchisement AR</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      touch-action: none;
      background: #000;
    }
    #politicalCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      pointer-events: none;
      background: #000;
      object-fit: cover;
      display: block;
    }
    #videoElement {
      display: none;
    }
  </style>
</head>
<body>
  <video id="videoElement" autoplay playsinline muted></video>
  <canvas id="politicalCanvas"></canvas>
  <script>
    const politicalCanvas = document.getElementById('politicalCanvas');
    const video = document.getElementById('videoElement');
    const ctx = politicalCanvas.getContext('2d');

    // AR Cluster settings (slower for smooth transitions)
    const WORD_INTERVAL = 50000;  // ms per text (slower for readability)
    const FADE_DURATION = 30000;  // ms for fade transition (slower for readability)
    const APPEAR_DURATION = 30000; // ms for new cluster/text fade-in
    const DISAPPEAR_DURATION = 30000; // ms for cluster/text fade-out
    const MAX_CLUSTERS = 5;

    // 100 brief, lower-case, multi-line movie/TV descriptions (no proper names, no sentence format)
    const popCultureSnippets = [
      "space travel\nalien encounters\nexploration of the unknown",
      "dystopian future\nrebellion against control\nsearch for freedom",
      "high school drama\nteen friendships\ncoming of age challenges",
      "crime investigation\nhidden motives\ntwisted mysteries",
      "family bonds\nlost and found\njourney home",
      "survival in wilderness\nresourcefulness\nhuman spirit tested",
      "fantasy world\nmagic and monsters\nepic quest",
      "forbidden love\nsocial barriers\nsacrifice and hope",
      "post-apocalyptic struggle\nscarcity of resources\ntrust issues",
      "team of superheroes\nsaving the world\nmoral dilemmas",
      "small town secrets\nunexpected horror\nunraveling truth",
      "life in prison\nredemption\nfriendship behind bars",
      "unexpected inheritance\nfamily rivalry\nhidden fortune",
      "road trip adventure\nself discovery\nunlikely companions",
      "time travel paradoxes\nchanging fate\nunintended consequences",
      "cooking competition\nrival chefs\nculinary creativity",
      "office politics\nawkward encounters\ndaily grind",
      "dream infiltration\nlayers of reality\nmind games",
      "search for treasure\nancient maps\nbooby traps",
      "lost memory\npiecing together clues\nidentity crisis",
      "magical boarding school\nrival houses\ncoming of age",
      "alien invasion\nhuman resistance\nsurvival tactics",
      "spies and double agents\ncovert missions\nbetrayal",
      "royal intrigue\npalace drama\nsuccession battles",
      "underdog sports team\nunlikely victory\nteamwork",
      "paranormal investigations\nhaunted locations\nskeptics and believers",
      "fashion industry\nrunway dreams\ncompetitive spirit",
      "organized crime\nfamily loyalty\nrise to power",
      "music festival\nfriendship\nfinding purpose",
      "disaster strikes\nrace against time\nheroic efforts",
      "robot uprising\nhuman survival\nethical dilemmas",
      "unexpected pregnancy\nlife changes\nsupport networks",
      "wild west showdown\nlaw vs outlaw\nrevenge",
      "urban legends\nteen dares\nnighttime suspense",
      "game show challenges\ncontestant strategies\nprizes at stake",
      "art heist\nelaborate planning\nmuseum security",
      "medical drama\nlife saving decisions\nhospital politics",
      "courtroom battles\nlegal twists\nsearch for justice",
      "hidden talents\nunlikely mentor\npersonal growth",
      "travel vlog\nglobal adventures\ncultural surprises",
      "remote island\nstranded strangers\ndecoding mysteries",
      "virtual reality\nidentity confusion\nescape attempts",
      "celebrity scandal\nmedia frenzy\nreputation at risk",
      "magical creatures\nhidden realms\nfriendship tested",
      "sports rivalry\ntraining montage\nfinal showdown",
      "political campaign\nbehind the scenes\nunexpected twists",
      "family reunion\nold wounds\nhealing together",
      "mountain climbing\nextreme conditions\nperseverance",
      "historical epic\nrise and fall\nlegacy",
      "baking contest\nsweet creations\nlast minute drama",
      "detective noir\nshadowy figures\nmoral ambiguity",
      "space station crisis\ncrew conflict\nrepair race",
      "parallel universes\nalternate lives\nchoices explored",
      "eccentric inventor\nbreakthrough discovery\nsabotage",
      "supernatural pact\nunleashed power\nfate rewritten",
      "fashion makeover\nconfidence boost\nunexpected romance",
      "startup launch\ntech innovation\nrival companies",
      "secret society\nhidden rituals\nexposing the truth",
      "family road trip\nlost directions\nunexpected detours",
      "science experiment\naccidental results\nchaos unleashed",
      "alien friendship\nadapting to earth\nshared adventure",
      "teen rivalry\nschool politics\ncoming together",
      "hotel mystery\neccentric guests\nhidden agendas",
      "pirate crew\nsearch for gold\nmutiny threats",
      "urban fantasy\ncreatures among us\nmagic in shadows",
      "holiday gathering\nold traditions\nnew beginnings",
      "space race\ninternational rivals\nunexpected alliances",
      "unexpected illness\nhealing journey\nfamily support",
      "hidden bunker\nsurvival strategy\ntrust issues",
      "wedding planning\nchaotic mishaps\nfamily drama",
      "dance competition\ncreative routines\nrival performers",
      "secret laboratory\nforbidden experiments\ngovernment cover-up",
      "lost artifact\nancient prophecy\nadventure quest",
      "desert trek\nsearch for water\nendurance",
      "cult leader\nnew recruits\nbreaking free",
      "summer camp\noutdoor challenges\nfriendship",
      "art school\ncreative rivalry\ninspiration",
      "robot companion\nlearning emotions\nunexpected bond",
      "train journey\nstrangers colliding\nshared stories",
      "tech startup\nfunding struggles\ninnovation race",
      "haunted mansion\nghostly encounters\nfamily secrets",
      "magician's apprentice\nnew tricks\nstage rivalry",
      "political scandal\nmedia investigation\ncover-up",
      "remote village\noutsider arrives\ncultural clash",
      "lost city\nancient curse\nexploration",
      "snowstorm survival\nfinding shelter\nteamwork",
      "unexpected inheritance\nfamily secrets\nrivalry",
      "futuristic city\nsocial divisions\nrebellion",
      "detective duo\ntwisted case\ndark secrets",
      "end of world\nlast survivors\nsearch for hope",
      "submarine adventure\ndeep sea mysteries\ncrew unity",
      "forest retreat\npersonal healing\ngroup dynamics",
      "cooking travel\nlocal flavors\nculinary journey",
      "martial arts school\ntraining discipline\nhonor",
      "magical forest\nhidden trails\ncreature encounters",
      "space colony\nresource scarcity\nnew society",
      "lost pet\ncommunity search\nemotional journey",
      "urban explorers\nabandoned sites\nhidden dangers",
      "television newsroom\nbreaking stories\nstaff rivalry"
      // Add more if needed
    ];

    // Expanded color sampling (keep original logic for greenish/cyan/yellowish)
    function isWideRangeColor(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      let max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = ((g - b) / d + (g < b ? 6 : 0)); break;
          case g: h = ((b - r) / d + 2); break;
          case b: h = ((r - g) / d + 4); break;
        }
        h /= 6;
      }
      const greenish = h >= 0.2 && h <= 0.45;
      const yellowish = h >= 0.12 && h < 0.2;
      const cyanish = h > 0.45 && h < 0.55;
      const bright = l > 0.28;
      const colorful = s > 0.35;
      return (greenish || yellowish || cyanish) && bright && colorful;
    }

    // Cluster detection with flag for clusters moving out of view
    function clusterColorPixels(data, width, height) {
      const visited = new Uint8Array(width * height);
      const clusters = [];
      const pixelIndex = (x, y) => (y * width + x) * 4;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          if (visited[idx]) continue;
          const i = pixelIndex(x, y);
          if (isWideRangeColor(data[i], data[i + 1], data[i + 2])) {
            const queue = [[x, y]];
            const cluster = [];
            let minX = x, maxX = x, minY = y, maxY = y;
            visited[idx] = 1;
            while (queue.length) {
              const [cx, cy] = queue.pop();
              cluster.push([cx, cy]);
              minX = Math.min(minX, cx); maxX = Math.max(maxX, cx);
              minY = Math.min(minY, cy); maxY = Math.max(maxY, cy);
              for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                  const nx = cx + dx, ny = cy + dy;
                  if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                  const nidx = ny * width + nx;
                  if (!visited[nidx]) {
                    const ni = pixelIndex(nx, ny);
                    if (isWideRangeColor(data[ni], data[ni + 1], data[ni + 2])) {
                      queue.push([nx, ny]);
                      visited[nidx] = 1;
                    }
                  }
                }
              }
            }
            // Only keep clusters fully visible
            if (
              cluster.length > 18 &&
              minX > 0 && maxX < width - 1 &&
              minY > 0 && maxY < height - 1
            ) {
              clusters.push(cluster);
              if (clusters.length >= MAX_CLUSTERS) return clusters; // Limit to 5 clusters
            }
          }
        }
      }
      return clusters;
    }

    function getClusterCenter(cluster) {
      let sumX = 0, sumY = 0;
      for (const [x, y] of cluster) {
        sumX += x;
        sumY += y;
      }
      return [sumX / cluster.length, sumY / cluster.length];
    }

    function getClusterSize(cluster) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const [x, y] of cluster) {
        minX = Math.min(minX, x); maxX = Math.max(maxX, x);
        minY = Math.min(minY, y); maxY = Math.max(maxY, y);
      }
      return Math.sqrt((maxX - minX) * (maxY - minY) + cluster.length); // area proxy
    }

    function pickSnippet() {
      return popCultureSnippets[Math.floor(Math.random() * popCultureSnippets.length)];
    }

    // Cluster management with fade-in/fade-out
    let clusterStates = [];
    let prevClusterCenters = [];

    function updateClusters(currentCenters, currentSizes) {
      // Match clusters by proximity
      let newStates = [];
      let matched = new Set();
      for (let i = 0; i < currentCenters.length; i++) {
        let center = currentCenters[i];
        let size = currentSizes[i];
        let foundIdx = -1, minDist = Infinity;
        for (let j = 0; j < clusterStates.length; j++) {
          let prev = clusterStates[j];
          if (prev.status === "disappearing") continue;
          let dist = Math.hypot(center[0] - prev.center[0], center[1] - prev.center[1]);
          if (dist < 60 && dist < minDist && !matched.has(j)) {
            minDist = dist;
            foundIdx = j;
          }
        }
        if (foundIdx !== -1) {
          // Existing cluster: update center & size
          let prev = clusterStates[foundIdx];
          newStates.push({
            ...prev,
            center,
            size,
            appearStart: prev.appearStart,
            status: "visible",
            disappearStart: null,
            lastUpdate: Date.now()
          });
          matched.add(foundIdx);
        } else {
          // New cluster: fade in
          newStates.push({
            center,
            size,
            snippet: pickSnippet(),
            nextSnippet: pickSnippet(),
            textFade: 1,
            textLastChange: Date.now(),
            appearStart: Date.now(),
            status: "appearing",
            disappearStart: null,
            depth: Math.random(),
            lastUpdate: Date.now()
          });
        }
      }

      // Existing clusters not matched: fade out
      for (let j = 0; j < clusterStates.length; j++) {
        if (matched.has(j)) continue;
        let prev = clusterStates[j];
        if (prev.status === "disappearing" && prev.disappearStart && Date.now() - prev.disappearStart < DISAPPEAR_DURATION) {
          // Continue fading out
          newStates.push(prev);
        } else if (prev.status !== "disappearing") {
          // Start fade out
          newStates.push({
            ...prev,
            status: "disappearing",
            disappearStart: Date.now()
          });
        }
      }
      // Limit to MAX_CLUSTERS
      clusterStates = newStates.slice(0, MAX_CLUSTERS);
    }

    function updateTextTransitions() {
      const now = Date.now();
      for (let cluster of clusterStates) {
        // Fade-in new cluster
        if (cluster.status === "appearing" && cluster.appearStart) {
          let t = (now - cluster.appearStart) / APPEAR_DURATION;
          cluster.appearProgress = Math.min(1, t);
          if (cluster.appearProgress >= 1) {
            cluster.status = "visible";
            cluster.appearStart = null;
            cluster.appearProgress = 1;
          }
        }
        // Fade-out disappearing cluster
        if (cluster.status === "disappearing" && cluster.disappearStart) {
          let t = (now - cluster.disappearStart) / DISAPPEAR_DURATION;
          cluster.disappearProgress = Math.min(1, t);
        }
        // Text fade (for changing snippets)
        if (cluster.textFade < 1) {
          let t = (now - cluster.textLastChange) / FADE_DURATION;
          cluster.textFade = Math.min(1, t);
          if (cluster.textFade >= 1) {
            cluster.snippet = cluster.nextSnippet;
          }
        }
      }
    }

    function triggerTextChanges() {
      for (let cluster of clusterStates) {
        cluster.nextSnippet = pickSnippet();
        cluster.textFade = 0;
        cluster.textLastChange = Date.now();
        cluster.depth = Math.random();
      }
    }

    // Spline for smooth curves
    function getSplinePoints(points, tension = 0.5, numOfSeg = 18) {
      if (points.length < 2) return points;
      let result = [];
      for (let i = 0; i < points.length - 1; i++) {
        let p0 = points[i === 0 ? i : i - 1];
        let p1 = points[i];
        let p2 = points[i + 1];
        let p3 = points[i + 2 < points.length ? i + 2 : i + 1];
        for (let t = 0; t < numOfSeg; t++) {
          let st = t / numOfSeg;
          let x = catmullRom(p0[0], p1[0], p2[0], p3[0], st, tension);
          let y = catmullRom(p0[1], p1[1], p2[1], p3[1], st, tension);
          result.push([x, y]);
        }
      }
      return result;
    }

    function catmullRom(p0, p1, p2, p3, t, tension) {
      let v0 = (p2 - p0) * tension;
      let v1 = (p3 - p1) * tension;
      return (2 * p1 - 2 * p2 + v0 + v1) * t * t * t
           + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t * t
           + v0 * t
           + p1;
    }

    function drawColorOverlays(ctx, clusters) {
      updateTextTransitions();
      ctx.save();
      // Draw smooth spline if enough clusters
      let centers = clusters.filter(c => c.status !== "disappearing" || (c.status === "disappearing" && c.disappearProgress < 1)).map(c => c.center);
      if (centers.length >= 2) {
        let spline = getSplinePoints(centers, 0.5, 18);
        ctx.beginPath();
        ctx.strokeStyle = "#FF4141";
        ctx.lineWidth = 2.5;
        ctx.shadowColor = "#FF4141";
        ctx.shadowBlur = 16;
        for (let i = 0; i < spline.length - 1; i++) {
          let [x1, y1] = spline[i];
          let [x2, y2] = spline[i + 1];
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
        }
        // Fade lines based on min cluster alpha (to avoid flicker)
        let minAlpha = 1.0;
        for (let c of clusters) {
          let alpha = 1.0;
          if (c.status === "appearing") alpha = c.appearProgress || 0;
          if (c.status === "disappearing") alpha = 1 - (c.disappearProgress || 0);
          minAlpha = Math.min(minAlpha, alpha);
        }
        ctx.globalAlpha = 0.38 + minAlpha * 0.3;
        ctx.stroke();
        ctx.globalAlpha = 1.0;
      }
      // Multi-line text at cluster centers
      for (let i = 0; i < clusters.length; i++) {
        let cluster = clusters[i];
        let [x, y] = cluster.center;
        let z = cluster.depth || 0;
        let size = cluster.size;
        let minFont = 18, maxFont = 38;
        let norm = Math.max(0, Math.min(1, (size - 120) / (politicalCanvas.width * 0.13)));
        let fontSize = Math.round(minFont + norm * (maxFont - minFont) * (1 - z * 0.5));
        let minAlpha = 0.52, maxAlpha = 0.88;
        let alpha = maxAlpha - z * (maxAlpha - minAlpha);

        // Fade-in or fade-out for clusters
        let appearAlpha = 1.0;
        if (cluster.status === "appearing") appearAlpha = cluster.appearProgress || 0;
        if (cluster.status === "disappearing") appearAlpha = 1 - (cluster.disappearProgress || 0);
        alpha *= appearAlpha;

        // Fade text transitions
        let snippet, snippetAlpha;
        if (cluster.textFade < 1) {
          snippet = cluster.nextSnippet;
          snippetAlpha = alpha * cluster.textFade * 0.85 + 0.15 * alpha;
        } else {
          snippet = cluster.snippet;
          snippetAlpha = alpha;
        }

        // Prevent flicker by smoothly fading in/out and keeping alpha above a minimum threshold
        snippetAlpha = Math.max(0.14, snippetAlpha);

        ctx.save();
        ctx.translate(x, y);
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "#FF4141";
        ctx.shadowBlur = 20;
        ctx.globalAlpha = snippetAlpha;
        ctx.fillStyle = "#FF4141";

        // Draw multi-line text (no sentence format, lower case)
        let lines = snippet.split('\n');
        let lineHeight = fontSize * 1.18;
        let baseY = -((lines.length - 1) * lineHeight) / 2;
        for (let li = 0; li < lines.length; li++) {
          ctx.fillText(lines[li], 0, baseY + li * lineHeight);
        }

        ctx.restore();
      }
      ctx.restore();
    }

    let lastTextTrigger = Date.now();

    function draw() {
      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        if (politicalCanvas.width !== video.videoWidth || politicalCanvas.height !== video.videoHeight) {
          politicalCanvas.width = video.videoWidth;
          politicalCanvas.height = video.videoHeight;
        }
        ctx.filter = "blur(1.5px) brightness(1.18) contrast(1.18)";
        ctx.drawImage(video, 0, 0, politicalCanvas.width, politicalCanvas.height);
        ctx.filter = "none";
        let frame = ctx.getImageData(0, 0, politicalCanvas.width, politicalCanvas.height);
        let data = frame.data;
        let clusters = clusterColorPixels(data, politicalCanvas.width, politicalCanvas.height);
        let clusterCenters = clusters.map(getClusterCenter);
        let clusterAreaSizes = clusters.map(getClusterSize);

        // Cluster fade-in/fade-out management
        updateClusters(clusterCenters, clusterAreaSizes);

        // If clusters have changed or moved out, update instantly (no flicker, slow transition)
        let centersChanged = false;
        if (prevClusterCenters.length !== clusterCenters.length) {
          centersChanged = true;
        } else {
          for (let i = 0; i < clusterCenters.length; i++) {
            if (
              Math.abs(clusterCenters[i][0] - (prevClusterCenters[i]?.[0] || 0)) > 80 ||
              Math.abs(clusterCenters[i][1] - (prevClusterCenters[i]?.[1] || 0)) > 80
            ) {
              centersChanged = true;
              break;
            }
          }
        }
        prevClusterCenters = clusterCenters.slice();

        if (Date.now() - lastTextTrigger >= WORD_INTERVAL) {
          triggerTextChanges();
          lastTextTrigger = Date.now();
        }

        drawColorOverlays(ctx, clusterStates);
      }
      requestAnimationFrame(draw);
    }

    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false })
      .then(stream => {
        video.srcObject = stream;
        video.play();
        video.addEventListener('loadedmetadata', () => {
          politicalCanvas.width = video.videoWidth;
          politicalCanvas.height = video.videoHeight;
          draw();
        });
      })
      .catch(() => {
        alert('Camera access denied or unavailable.');
      });

    window.addEventListener('resize', () => {
      politicalCanvas.width = window.innerWidth;
      politicalCanvas.height = window.innerHeight;
    });

    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        politicalCanvas.width = window.innerWidth;
        politicalCanvas.height = window.innerHeight;
      }, 500);
    });
  </script>
</body>
</html>
