<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>tvtalk ar</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
  <style>
    html, body { margin:0; padding:0; height:100%; width:100%; overflow:hidden; background:#000;}
    #politicalCanvas, #videoElement {position:fixed; top:0; left:0; width:100vw; height:100vh; object-fit:cover;}
    #politicalCanvas {z-index:2; pointer-events:none; background:transparent;}
    #videoElement {z-index:1; background:#000;}
  </style>
</head>
<body>
<video id="videoElement" autoplay playsinline muted></video>
<canvas id="politicalCanvas"></canvas>
<script>
const pc = document.getElementById('politicalCanvas');
const v = document.getElementById('videoElement');
const ctx = pc.getContext('2d');

// Reduced intervals and limits for performance
const INTERVAL = 120000, APPEAR = 25000, DISAPPEAR = 1200, MAX = 3, FROZEN = 2000, FMIN = 1000, FMAX = 4000, HSZ = 10;
const descs = [
  "friends discover secrets in their town",
  "artist creates beauty from waste",
  "scientist races for a cure",
  "family finds adventure on a road trip",
  "detective unravels lies in a city",
  "musician inspired by everyday sounds",
  "chef blends tradition and innovation",
  "teacher motivates students",
  "young athlete trains for competition",
  "writer explores new worlds",
  "engineer builds bridges",
  "child invents a playground game",
  "painter inspired by seasons",
  "traveler learns meaning of home",
  "doctor comforts patients",
  "entrepreneur launches startup",
  "gardener cultivates rare flowers",
  "programmer solves a bug",
  "astronaut gazes at earth",
  "historian uncovers stories",
  "filmmaker captures moments",
  "poet writes verses"
];

function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.random()*(i+1)|0;[a[i],a[j]]=[a[j],a[i]];}return a}
function pickDesc(){return descs[Math.random()*descs.length|0];}

const isLight = (r,g,b) => (0.2126*r+0.7152*g+0.0722*b)/255 > 0.5;

function clusterLightPix(dat,w,h){
  const vis=new Uint8Array(w*h),cls=[];
  for(let y=0;y<h;y++)for(let x=0;x<w;x++){
    let idx=y*w+x, i=idx*4;
    if(vis[idx]||!isLight(dat[i],dat[i+1],dat[i+2])) continue;
    let q=[[x,y]],c=[];
    vis[idx]=1;
    while(q.length){
      let [cx,cy]=q.pop(); c.push([cx,cy]);
      for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){
        let nx=cx+dx,ny=cy+dy;
        if(nx<0||nx>=w||ny<0||ny>=h)continue;
        let nidx=ny*w+nx,ni=nidx*4;
        if(!vis[nidx]&&isLight(dat[ni],dat[ni+1],dat[ni+2])){q.push([nx,ny]);vis[nidx]=1;}
      }
    }
    if(c.length>18){cls.push(c);if(cls.length>=MAX)return cls;}
  }
  return cls;
}
const clusterCenter = c => c.reduce((a,[x,y])=>[a[0]+x,a[1]+y],[0,0]).map(z=>z/c.length);
const clusterSize = c => {
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(const[x,y]of c){minX=Math.min(minX,x);maxX=Math.max(maxX,x);minY=Math.min(minY,y);maxY=Math.max(maxY,y);}
  return Math.sqrt((maxX-minX)**2+(maxY-minY)**2);
};

let clusters=[], prevCenters=[], lastPara=Date.now();
function clusDiff(cur,pre){if(cur.length!==pre.length)return 1;for(let i=0;i<cur.length;i++)if(!pre[i]||Math.abs(cur[i][0]-pre[i][0])>25||Math.abs(cur[i][1]-pre[i][1])>25)return 1;return 0;}
function updateClusters(curC,curS,refresh){
  let nst=[],mt=new Set();
  for(let i=0;i<curC.length;i++){
    let c=curC[i],s=curS[i],f=-1,minD=Infinity;
    for(let j=0;j<clusters.length;j++){
      let p=clusters[j];
      if(p.status==="disappearing")continue;
      let d=Math.hypot(c[0]-p.c[0],c[1]-p.c[1]);
      if(d<60&&d<minD&&!mt.has(j)){minD=d;f=j;}
    }
    if(f!=-1){
      let p=clusters[f];
      nst.push({...p,size:s,c:c,appearS:p.appearS,status:"visible",disappearS:null,last:Date.now(),desc:refresh?pickDesc():p.desc});
      mt.add(f);
    }else{
      nst.push({c,s,desc:pickDesc(),appearS:Date.now(),status:"appearing",disappearS:null,last:Date.now()});
    }
  }
  for(let j=0;j<clusters.length;j++){
    if(mt.has(j))continue;
    let p=clusters[j];
    if(p.status==="disappearing"&&p.disappearS&&Date.now()-p.disappearS<DISAPPEAR)nst.push(p);
    else if(p.status!=="disappearing")nst.push({...p,status:"disappearing",disappearS:Date.now()});
  }
  clusters = nst.slice(0,MAX);
}
function updateDescTrans(){
  const now=Date.now();
  for(let c of clusters){
    if(c.status==="appearing"&&c.appearS){
      let t=(now-c.appearS)/APPEAR;
      c.appearP=Math.min(1,t);
      if(c.appearP>=1){c.status="visible";c.appearS=null;c.appearP=1;}
    }
    if(c.status==="disappearing"&&c.disappearS){let t=(now-c.disappearS)/DISAPPEAR;c.disappearP=Math.min(1,t);}
  }
}

const frozen={active:false,text:""};
let nextTimeout=null;
function scheduleFreeze(){
  clearTimeout(nextTimeout);
  nextTimeout = setTimeout(startFreeze, Math.random()*(FMAX-FMIN)+FMIN);
}
function startFreeze(){
  frozen.active = true;
  frozen.text = pickDesc();
  setTimeout(()=>{
    frozen.active = false;
    scheduleFreeze();
  }, FROZEN);
}
function drawFrozen(ctx,text){
  let maxF=Math.round(Math.min(pc.width,pc.height)/12),minF=20,fnt=maxF,maxW=pc.width*0.95,maxH=pc.height*0.92;
  ctx.font=`bold ${fnt}px Arial,sans-serif`;
  let fits=0,lines=[text];
  while(!fits&&fnt>=minF){
    ctx.font=`bold ${fnt}px Arial,sans-serif`;
    let widest=ctx.measureText(text).width,lh=fnt*1.4,totalH=lh;
    if(widest<=maxW&&totalH<=maxH)fits=1;else{fnt-=2;}
  }
  ctx.save();ctx.globalAlpha=1;ctx.textAlign="center";ctx.textBaseline="middle";ctx.fillStyle="#FF2020";ctx.font=`bold ${fnt}px Arial,sans-serif`;
  let cx=pc.width/2,cy=pc.height/2;
  ctx.fillText(text,cx,cy);
  ctx.restore();
}
function draw(){
  if(v.readyState===v.HAVE_ENOUGH_DATA&&v.videoWidth>0&&v.videoHeight>0){
    if(pc.width!==v.videoWidth||pc.height!==v.videoHeight){pc.width=v.videoWidth;pc.height=v.videoHeight;}
    ctx.clearRect(0,0,pc.width,pc.height);ctx.drawImage(v,0,0,pc.width,pc.height);
    if(frozen.active){drawFrozen(ctx,frozen.text);}
    else {
      let frame=ctx.getImageData(0,0,pc.width,pc.height),data=frame.data,cls=[],centers=[],sizes=[];
      try{cls=clusterLightPix(data,pc.width,pc.height);centers=cls.map(clusterCenter);sizes=cls.map(clusterSize);}catch(e){cls=[];centers=[];sizes=[];}
      let force=clusDiff(centers,prevCenters);
      if(force&&centers.length>0){updateClusters(centers,sizes,1);lastPara=Date.now();}
      else if(Date.now()-lastPara>=INTERVAL){updateClusters(centers,sizes,1);lastPara=Date.now();}
      else if(clusters.length===0){updateClusters(centers,sizes,1);}
      else updateClusters(centers,sizes,0);
      prevCenters=centers;
      updateDescTrans();
      for(let c of clusters){
        let[x,y]=c.c,s=c.size,fnt=Math.max(20,Math.round(Math.min(pc.width,pc.height)/24)),desc=c.desc;
        let alpha = c.status==="appearing"?c.appearP||0:c.status==="disappearing"?1-(c.disappearP||0):1;
        ctx.save();
        ctx.translate(x,y);
        ctx.font=`bold ${fnt}px Arial,sans-serif`;ctx.textAlign="center";ctx.textBaseline="middle";ctx.globalAlpha=alpha;ctx.fillStyle="#FF2020";
        ctx.fillText(desc,0,0);
        ctx.restore();
      }
    }
  }
  requestAnimationFrame(draw);
}

navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false})
  .then(s=>{
    v.srcObject=s;v.play();v.addEventListener('loadedmetadata',()=>{
      if(v.videoWidth>0&&v.videoHeight>0){pc.width=v.videoWidth;pc.height=v.videoHeight;}
      else{pc.width=window.innerWidth;pc.height=window.innerHeight;}
      draw();scheduleFreeze();
    });
  }).catch(()=>alert('camera access denied or unavailable'));

window.addEventListener('resize',()=>{pc.width=window.innerWidth;pc.height=window.innerHeight;});
window.addEventListener('orientationchange',()=>{setTimeout(()=>{pc.width=window.innerWidth;pc.height=window.innerHeight;},500);});
</script>
</body>
</html>
