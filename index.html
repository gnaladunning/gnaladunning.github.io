<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Political Disenfranchisement AR</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      touch-action: none;
      background: #000;
    }
    #politicalCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      pointer-events: none;
      background: #000;
      object-fit: cover;
      display: block;
    }
    #videoElement {
      display: none;
    }
  </style>
</head>
<body>
  <video id="videoElement" autoplay playsinline muted></video>
  <canvas id="politicalCanvas"></canvas>
  <script>
    const politicalCanvas = document.getElementById('politicalCanvas');
    const video = document.getElementById('videoElement');
    const ctx = politicalCanvas.getContext('2d');

    // AR Cluster settings (slower for smooth transitions)
    const WORD_INTERVAL = 50000;  // ms per text (slower for readability)
    const FADE_DURATION = 30000;  // ms for fade transition (slower for readability)
    const APPEAR_DURATION = 30000; // ms for new cluster/text fade-in
    const DISAPPEAR_DURATION = 30000; // ms for cluster/text fade-out
    const MAX_CLUSTERS = 5;

    // 100 brief, natural, conversational movie/TV descriptions
    const popCultureSnippets = [
      "a crew heads into deep space, hoping to find new worlds but ends up facing strange creatures",
      "a group fights against a controlling regime in a bleak future, risking it all for freedom",
      "teens deal with crushes, drama, and growing up in a high school where everything feels intense",
      "a detective digs into a tangled crime, finding secrets nobody wants uncovered",
      "family members set out on a journey to reconnect after years apart",
      "lost in the wild, people have to work together to survive with barely anything",
      "heroes with magic and swords go on a quest to save their world from dark forces",
      "two people fall in love, but everyone around them tries to keep them apart",
      "after the world ends, survivors try to trust each other while searching for food and hope",
      "superheroes team up to stop disaster, but each has their own struggles",
      "in a quiet town, strange things start happening and secrets come to light",
      "life behind bars is tough, but friendships help people find redemption",
      "a surprise inheritance brings out old rivalries and family drama",
      "friends hit the road together, discovering more about themselves as they travel",
      "someone changes the past and ends up in a whirlwind of unexpected consequences",
      "chefs battle it out in the kitchen, creating wild dishes to impress the judges",
      "awkward moments and office politics make every workday unpredictable",
      "dreams and reality mix together, making everyone question what’s real",
      "a hunt for lost treasure leads to ancient traps and dangerous adventures",
      "someone wakes up with no memory, trying to put the pieces of their life together",
      "kids learn magic at a boarding school, facing rivalries and big challenges",
      "aliens invade, and humans scramble to survive against impossible odds",
      "spies go undercover, trying to outsmart each other while keeping secrets",
      "royal families clash over who will rule, with backstabbing at every turn",
      "an underdog sports team trains hard and finally pulls off a big win",
      "ghost hunters try to prove the supernatural is real, exploring haunted places",
      "fashion hopefuls chase their dreams on the runway, facing tough competition",
      "a crime family rises to power, torn between loyalty and ambition",
      "friends at a music festival have life-changing experiences and discover their passions",
      "a disaster strikes, and ordinary people jump in to save the day",
      "robots rebel against humans, forcing everyone to question what makes us human",
      "an unexpected pregnancy shakes up lives, bringing people together",
      "cowboys and outlaws face off in a dusty town, seeking justice or revenge",
      "urban legends come alive as teens dare each other to face their fears",
      "contestants battle through zany challenges on a game show hoping to win big",
      "a clever art thief plans a heist, but security is tighter than expected",
      "doctors make split-second decisions in the ER, saving lives and dealing with drama",
      "lawyers go head-to-head in court, with plenty of twists",
      "a hidden talent gets discovered, changing someone’s life with the help of a mentor",
      "travel vloggers explore the world and are surprised by new cultures",
      "strangers stranded on a remote island work together to solve its mysteries",
      "virtual reality blurs the lines of identity and escape",
      "a celebrity’s mistake sparks a media frenzy and threatens their reputation",
      "teenagers discover magical creatures lurking in secret worlds",
      "rival sports teams train hard to win the big championship",
      "behind the scenes of a political campaign, things get messy and unpredictable",
      "family members reunite, dealing with old wounds and finding forgiveness",
      "mountaineers push themselves in harsh conditions to reach the summit",
      "a historical saga shows a dynasty’s rise and fall over generations",
      "bakers whip up amazing desserts and scramble to finish before time runs out",
      "a detective walks dark city streets, facing moral dilemmas",
      "an accident on a space station forces the crew to work together or risk disaster",
      "parallel universes let people see how life could have been different",
      "an eccentric inventor makes a breakthrough, but sabotage lurks",
      "a mysterious pact unleashes powers that can change fate itself",
      "a fashion makeover brings confidence and maybe sparks a new romance",
      "young entrepreneurs battle rivals to launch their tech startup",
      "a secret society has rituals nobody on the outside understands",
      "a family road trip goes hilariously off track with wild detours",
      "a science experiment goes wrong, and chaos erupts in the lab",
      "an alien befriends a kid, trying to adjust to life on earth",
      "rival teens compete at school, but end up working together",
      "guests at a quirky hotel hide secrets as mysteries unfold",
      "pirates search for treasure but face betrayal from within",
      "urban fantasy brings magic into everyday city life",
      "a holiday brings a family together, mixing old traditions with new beginnings",
      "countries race to win the space race, forming unlikely alliances",
      "an illness prompts a family to support each other through tough times",
      "people hide out in a bunker, unsure who to trust",
      "planning a wedding turns into a comedy of errors and family chaos",
      "dancers push their limits in a fierce competition",
      "scientists conduct forbidden experiments in a top-secret lab",
      "an ancient artifact leads adventurers on a wild quest",
      "people trek across the desert, desperate for water and survival",
      "new recruits join a cult but soon question its leader",
      "kids at summer camp tackle outdoor challenges and form lasting friendships",
      "art students compete for recognition and inspiration",
      "a robot companion learns about emotions and bonds with its human",
      "strangers on a train share stories during a long ride",
      "founders of a startup struggle to get funding and outsmart rivals",
      "a family moves into a haunted mansion, uncovering secrets from the past",
      "a magician’s apprentice learns dazzling tricks and faces a rival",
      "a political scandal unravels as journalists chase the truth",
      "an outsider arrives in a remote village, shaking up the community",
      "explorers search for a lost city and face an ancient curse",
      "a snowstorm forces strangers to work together to survive",
      "a surprise inheritance reveals secrets and sparks a family feud",
      "in a futuristic city, people rebel against strict social divisions",
      "two detectives team up to crack a dark, twisted case",
      "the world ends, and a handful of survivors hunt for hope",
      "a submarine crew explores deep-sea mysteries, relying on unity",
      "a forest retreat helps people heal and discover new bonds",
      "chefs travel the world, tasting local flavors and learning new recipes",
      "martial arts students train hard, learning about honor and discipline",
      "adventurers explore a magical forest full of hidden trails and creatures",
      "colonists on a faraway planet must manage scarce resources",
      "a lost pet brings a community together for a heartfelt search",
      "urban explorers sneak into abandoned sites, facing unexpected dangers",
      "newsroom staff race to cover breaking stories while competing for scoops"
      // Add more if needed
    ];

    // Expanded color sampling (keep original logic for greenish/cyan/yellowish)
    function isWideRangeColor(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      let max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = ((g - b) / d + (g < b ? 6 : 0)); break;
          case g: h = ((b - r) / d + 2); break;
          case b: h = ((r - g) / d + 4); break;
        }
        h /= 6;
      }
      const greenish = h >= 0.2 && h <= 0.45;
      const yellowish = h >= 0.12 && h < 0.2;
      const cyanish = h > 0.45 && h < 0.55;
      const bright = l > 0.28;
      const colorful = s > 0.35;
      return (greenish || yellowish || cyanish) && bright && colorful;
    }

    // Cluster detection with flag for clusters moving out of view
    function clusterColorPixels(data, width, height) {
      const visited = new Uint8Array(width * height);
      const clusters = [];
      const pixelIndex = (x, y) => (y * width + x) * 4;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          if (visited[idx]) continue;
          const i = pixelIndex(x, y);
          if (isWideRangeColor(data[i], data[i + 1], data[i + 2])) {
            const queue = [[x, y]];
            const cluster = [];
            let minX = x, maxX = x, minY = y, maxY = y;
            visited[idx] = 1;
            while (queue.length) {
              const [cx, cy] = queue.pop();
              cluster.push([cx, cy]);
              minX = Math.min(minX, cx); maxX = Math.max(maxX, cx);
              minY = Math.min(minY, cy); maxY = Math.max(maxY, cy);
              for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                  const nx = cx + dx, ny = cy + dy;
                  if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                  const nidx = ny * width + nx;
                  if (!visited[nidx]) {
                    const ni = pixelIndex(nx, ny);
                    if (isWideRangeColor(data[ni], data[ni + 1], data[ni + 2])) {
                      queue.push([nx, ny]);
                      visited[nidx] = 1;
                    }
                  }
                }
              }
            }
            // Only keep clusters fully visible
            if (
              cluster.length > 18 &&
              minX > 0 && maxX < width - 1 &&
              minY > 0 && maxY < height - 1
            ) {
              clusters.push(cluster);
              if (clusters.length >= MAX_CLUSTERS) return clusters; // Limit to 5 clusters
            }
          }
        }
      }
      return clusters;
    }

    function getClusterCenter(cluster) {
      let sumX = 0, sumY = 0;
      for (const [x, y] of cluster) {
        sumX += x;
        sumY += y;
      }
      return [sumX / cluster.length, sumY / cluster.length];
    }

    function getClusterSize(cluster) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const [x, y] of cluster) {
        minX = Math.min(minX, x); maxX = Math.max(maxX, x);
        minY = Math.min(minY, y); maxY = Math.max(maxY, y);
      }
      return Math.sqrt((maxX - minX) * (maxY - minY) + cluster.length); // area proxy
    }

    function pickSnippet() {
      return popCultureSnippets[Math.floor(Math.random() * popCultureSnippets.length)];
    }

    // Cluster management with fade-in/fade-out
    let clusterStates = [];
    let prevClusterCenters = [];

    function updateClusters(currentCenters, currentSizes) {
      // Match clusters by proximity
      let newStates = [];
      let matched = new Set();
      for (let i = 0; i < currentCenters.length; i++) {
        let center = currentCenters[i];
        let size = currentSizes[i];
        let foundIdx = -1, minDist = Infinity;
        for (let j = 0; j < clusterStates.length; j++) {
          let prev = clusterStates[j];
          if (prev.status === "disappearing") continue;
          let dist = Math.hypot(center[0] - prev.center[0], center[1] - prev.center[1]);
          if (dist < 60 && dist < minDist && !matched.has(j)) {
            minDist = dist;
            foundIdx = j;
          }
        }
        if (foundIdx !== -1) {
          // Existing cluster: update center & size
          let prev = clusterStates[foundIdx];
          newStates.push({
            ...prev,
            center,
            size,
            appearStart: prev.appearStart,
            status: "visible",
            disappearStart: null,
            lastUpdate: Date.now()
          });
          matched.add(foundIdx);
        } else {
          // New cluster: fade in
          newStates.push({
            center,
            size,
            snippet: pickSnippet(),
            nextSnippet: pickSnippet(),
            textFade: 1,
            textLastChange: Date.now(),
            appearStart: Date.now(),
            status: "appearing",
            disappearStart: null,
            depth: Math.random(),
            lastUpdate: Date.now()
          });
        }
      }

      // Existing clusters not matched: fade out
      for (let j = 0; j < clusterStates.length; j++) {
        if (matched.has(j)) continue;
        let prev = clusterStates[j];
        if (prev.status === "disappearing" && prev.disappearStart && Date.now() - prev.disappearStart < DISAPPEAR_DURATION) {
          // Continue fading out
          newStates.push(prev);
        } else if (prev.status !== "disappearing") {
          // Start fade out
          newStates.push({
            ...prev,
            status: "disappearing",
            disappearStart: Date.now()
          });
        }
      }
      // Limit to MAX_CLUSTERS
      clusterStates = newStates.slice(0, MAX_CLUSTERS);
    }

    function updateTextTransitions() {
      const now = Date.now();
      for (let cluster of clusterStates) {
        // Fade-in new cluster
        if (cluster.status === "appearing" && cluster.appearStart) {
          let t = (now - cluster.appearStart) / APPEAR_DURATION;
          cluster.appearProgress = Math.min(1, t);
          if (cluster.appearProgress >= 1) {
            cluster.status = "visible";
            cluster.appearStart = null;
            cluster.appearProgress = 1;
          }
        }
        // Fade-out disappearing cluster
        if (cluster.status === "disappearing" && cluster.disappearStart) {
          let t = (now - cluster.disappearStart) / DISAPPEAR_DURATION;
          cluster.disappearProgress = Math.min(1, t);
        }
        // Text fade (for changing snippets)
        if (cluster.textFade < 1) {
          let t = (now - cluster.textLastChange) / FADE_DURATION;
          cluster.textFade = Math.min(1, t);
          if (cluster.textFade >= 1) {
            cluster.snippet = cluster.nextSnippet;
          }
        }
      }
    }

    function triggerTextChanges() {
      for (let cluster of clusterStates) {
        cluster.nextSnippet = pickSnippet();
        cluster.textFade = 0;
        cluster.textLastChange = Date.now();
        cluster.depth = Math.random();
      }
    }

    // Spline for smooth curves
    function getSplinePoints(points, tension = 0.5, numOfSeg = 18) {
      if (points.length < 2) return points;
      let result = [];
      for (let i = 0; i < points.length - 1; i++) {
        let p0 = points[i === 0 ? i : i - 1];
        let p1 = points[i];
        let p2 = points[i + 1];
        let p3 = points[i + 2 < points.length ? i + 2 : i + 1];
        for (let t = 0; t < numOfSeg; t++) {
          let st = t / numOfSeg;
          let x = catmullRom(p0[0], p1[0], p2[0], p3[0], st, tension);
          let y = catmullRom(p0[1], p1[1], p2[1], p3[1], st, tension);
          result.push([x, y]);
        }
      }
      return result;
    }

    function catmullRom(p0, p1, p2, p3, t, tension) {
      let v0 = (p2 - p0) * tension;
      let v1 = (p3 - p1) * tension;
      return (2 * p1 - 2 * p2 + v0 + v1) * t * t * t
           + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t * t
           + v0 * t
           + p1;
    }

    function drawColorOverlays(ctx, clusters) {
      updateTextTransitions();
      ctx.save();
      // Draw smooth spline if enough clusters
      let centers = clusters.filter(c => c.status !== "disappearing" || (c.status === "disappearing" && c.disappearProgress < 1)).map(c => c.center);
      if (centers.length >= 2) {
        let spline = getSplinePoints(centers, 0.5, 18);
        ctx.beginPath();
        ctx.strokeStyle = "#FF4141";
        ctx.lineWidth = 2.5;
        ctx.shadowColor = "#FF4141";
        ctx.shadowBlur = 16;
        for (let i = 0; i < spline.length - 1; i++) {
          let [x1, y1] = spline[i];
          let [x2, y2] = spline[i + 1];
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
        }
        // Fade lines based on min cluster alpha (to avoid flicker)
        let minAlpha = 1.0;
        for (let c of clusters) {
          let alpha = 1.0;
          if (c.status === "appearing") alpha = c.appearProgress || 0;
          if (c.status === "disappearing") alpha = 1 - (c.disappearProgress || 0);
          minAlpha = Math.min(minAlpha, alpha);
        }
        ctx.globalAlpha = 0.38 + minAlpha * 0.3;
        ctx.stroke();
        ctx.globalAlpha = 1.0;
      }
      // Multi-line text at cluster centers
      for (let i = 0; i < clusters.length; i++) {
        let cluster = clusters[i];
        let [x, y] = cluster.center;
        let z = cluster.depth || 0;
        let size = cluster.size;
        let minFont = 18, maxFont = 38;
        let norm = Math.max(0, Math.min(1, (size - 120) / (politicalCanvas.width * 0.13)));
        let fontSize = Math.round(minFont + norm * (maxFont - minFont) * (1 - z * 0.5));
        let minAlpha = 0.52, maxAlpha = 0.88;
        let alpha = maxAlpha - z * (maxAlpha - minAlpha);

        // Fade-in or fade-out for clusters
        let appearAlpha = 1.0;
        if (cluster.status === "appearing") appearAlpha = cluster.appearProgress || 0;
        if (cluster.status === "disappearing") appearAlpha = 1 - (cluster.disappearProgress || 0);
        alpha *= appearAlpha;

        // Fade text transitions
        let snippet, snippetAlpha;
        if (cluster.textFade < 1) {
          snippet = cluster.nextSnippet;
          snippetAlpha = alpha * cluster.textFade * 0.85 + 0.15 * alpha;
        } else {
          snippet = cluster.snippet;
          snippetAlpha = alpha;
        }

        // Prevent flicker by smoothly fading in/out and keeping alpha above a minimum threshold
        snippetAlpha = Math.max(0.14, snippetAlpha);

        ctx.save();
        ctx.translate(x, y);
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "#FF4141";
        ctx.shadowBlur = 20;
        ctx.globalAlpha = snippetAlpha;
        ctx.fillStyle = "#FF4141";

        // Draw multi-line text (no sentence format, lower case)
        let lines = snippet.split('\n');
        let lineHeight = fontSize * 1.18;
        let baseY = -((lines.length - 1) * lineHeight) / 2;
        for (let li = 0; li < lines.length; li++) {
          ctx.fillText(lines[li], 0, baseY + li * lineHeight);
        }

        ctx.restore();
      }
      ctx.restore();
    }

    let lastTextTrigger = Date.now();

    function draw() {
      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        if (politicalCanvas.width !== video.videoWidth || politicalCanvas.height !== video.videoHeight) {
          politicalCanvas.width = video.videoWidth;
          politicalCanvas.height = video.videoHeight;
        }
        ctx.filter = "blur(1.5px) brightness(1.18) contrast(1.18)";
        ctx.drawImage(video, 0, 0, politicalCanvas.width, politicalCanvas.height);
        ctx.filter = "none";
        let frame = ctx.getImageData(0, 0, politicalCanvas.width, politicalCanvas.height);
        let data = frame.data;
        let clusters = clusterColorPixels(data, politicalCanvas.width, politicalCanvas.height);
        let clusterCenters = clusters.map(getClusterCenter);
        let clusterAreaSizes = clusters.map(getClusterSize);

        // Cluster fade-in/fade-out management
        updateClusters(clusterCenters, clusterAreaSizes);

        // If clusters have changed or moved out, update instantly (no flicker, slow transition)
        let centersChanged = false;
        if (prevClusterCenters.length !== clusterCenters.length) {
          centersChanged = true;
        } else {
          for (let i = 0; i < clusterCenters.length; i++) {
            if (
              Math.abs(clusterCenters[i][0] - (prevClusterCenters[i]?.[0] || 0)) > 80 ||
              Math.abs(clusterCenters[i][1] - (prevClusterCenters[i]?.[1] || 0)) > 80
            ) {
              centersChanged = true;
              break;
            }
          }
        }
        prevClusterCenters = clusterCenters.slice();

        if (Date.now() - lastTextTrigger >= WORD_INTERVAL) {
          triggerTextChanges();
          lastTextTrigger = Date.now();
        }

        drawColorOverlays(ctx, clusterStates);
      }
      requestAnimationFrame(draw);
    }

    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false })
      .then(stream => {
        video.srcObject = stream;
        video.play();
        video.addEventListener('loadedmetadata', () => {
          politicalCanvas.width = video.videoWidth;
          politicalCanvas.height = video.videoHeight;
          draw();
        });
      })
      .catch(() => {
        alert('Camera access denied or unavailable.');
      });

    window.addEventListener('resize', () => {
      politicalCanvas.width = window.innerWidth;
      politicalCanvas.height = window.innerHeight;
    });

    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        politicalCanvas.width = window.innerWidth;
        politicalCanvas.height = window.innerHeight;
      }, 500);
    });
  </script>
</body>
</html>
