<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Compositional Geometry Analyzer - AR Web</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <!-- MindAR and A-Frame CDN -->
  <script src="https://cdn.jsdelivr.net/npm/aframe@1.3.0/dist/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mindar@1.1.4/dist/mindar-image-aframe.prod.js"></script>
  <style>
    body {
      margin:0; padding:0; background: #181818;
      color: #fff; font-family:sans-serif;
      overflow: hidden;
    }
    #imageInput {
      position: absolute;
      top: 1em; left: 1em;
      z-index: 2;
      background: rgba(30,30,30,0.75);
      border-radius: 8px;
      padding: .5em;
    }
    .controls {
      position: absolute; right: 1em; top: 1em;
      z-index: 2;
      background:rgba(30,30,30,0.75);
      border-radius:8px; padding:.7em 1em; font-size:1em;
    }
    .controls label { display:block; margin-bottom:.3em; }
    #instructions {
      background:rgba(0,0,0,0.8); color:#fff;
      max-width: 450px;
      margin:.5em auto;
      border-radius: 8px;
      padding: 12px;
      font-size:1em;
      z-index: 3;
      position:relative;
      text-align:center;
    }
    #ar-container {
      width:100vw; height:100vh;
      position:fixed; left:0; top:0;
      overflow:hidden;
      z-index:1;
    }
    .aframe-container {
      width:100vw !important;
      height:100vh !important;
      position:absolute;
      left:0; top:0;
      pointer-events:auto;
      z-index:1;
      background:#111;
    }
    #cameraFeed {
      display: none;
      width: 0;
      height: 0;
    }
  </style>
</head>
<body>
  <div id="instructions">
    <b>Compositional Geometry AR Analyzer</b><br>
    1. Upload a photo or artwork.<br>
    2. Allow camera access when prompted.<br>
    3. Point the device camera at the real image.<br>
    4. Geometrical overlays (thirds, diagonals, curves, perspective, advanced element analysis) align in AR over the detected image.<br>
    <b>Move around to explore complex geometry!</b>
    <div style="margin-top:.7em; font-size:.93em;color:#aca;">
      Powered by <a href="https://hiukim.github.io/mind-ar-js-doc/" style="color:#cfa">MindAR</a> for WebXR/mobile AR.
    </div>
  </div>
  <input id="imageInput" type="file" accept="image/*">
  <div class="controls">
    <label><input type="checkbox" id="thirdsChk" checked> Rule of Thirds</label>
    <label><input type="checkbox" id="diagonalsChk" checked> Diagonals</label>
    <label><input type="checkbox" id="goldenChk"> Golden Ratio</label>
    <label><input type="checkbox" id="perspectiveChk"> Perspective</label>
    <label><input type="checkbox" id="curvesChk"> Dynamic Curves</label>
    <label><input type="checkbox" id="complexChk" checked> Complex Relationships</label>
  </div>
  <!-- AR container -->
  <div id="ar-container">
    <a-scene
        mindar-image="imageTargetSrc: #img-target; autoStart: false;"
        color-space="sRGB"
        embedded
        renderer="precision: highp; antialias: true;"
        vr-mode-ui="enabled: false"
        device-orientation-permission-ui="enabled: true"
        class="aframe-container"
        style="width:100vw; height:100vh;">
      <a-assets>
        <!-- MindAR loads target through this asset image -->
        <img id="img-target" crossorigin="anonymous" style="display:none;" />
      </a-assets>
      <a-camera make-default position="0 0 0"></a-camera>
      <a-entity mindar-image-target="targetIndex: 0">
        <a-plane id="artPlane" width="1" height="0.7" position="0 0 0" material="shader: flat; transparent:true;"></a-plane>
        <a-entity id="overlayGroup"></a-entity>
      </a-entity>
    </a-scene>
    <!-- Real camera feed (only visible when AR started; used as workaround for mobile browser issues) -->
    <video id="cameraFeed" autoplay playsinline muted></video>
  </div>
  <script>
    const imageInput = document.getElementById('imageInput');
    const imgTarget = document.getElementById('img-target');
    const artPlane = document.querySelector('#artPlane');
    const overlayGroup = document.getElementById('overlayGroup');
    const sceneEl = document.querySelector('a-scene');
    const cameraFeed = document.getElementById('cameraFeed');
    let arStarted = false;

    // overlays' states
    let overlays = {
      thirds: true,
      diagonals: true,
      golden: false,
      perspective: false,
      curves: false,
      complex: true
    };

    // Checkbox controls
    document.getElementById('thirdsChk').onchange = function(){ overlays.thirds = this.checked; drawOverlayGroup(); }
    document.getElementById('diagonalsChk').onchange = function(){ overlays.diagonals = this.checked; drawOverlayGroup(); }
    document.getElementById('goldenChk').onchange = function(){ overlays.golden = this.checked; drawOverlayGroup(); }
    document.getElementById('perspectiveChk').onchange = function(){ overlays.perspective = this.checked; drawOverlayGroup(); }
    document.getElementById('curvesChk').onchange = function(){ overlays.curves = this.checked; drawOverlayGroup(); }
    document.getElementById('complexChk').onchange = function(){ overlays.complex = this.checked; drawOverlayGroup(); }

    // IMAGE (TARGET) UPLOAD + CAMERA HANDLING
    imageInput.onchange = function(e){
      const file = e.target.files[0];
      if(!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        imgTarget.src = evt.target.result;
        artPlane.setAttribute("material", "src", evt.target.result);

        imgTarget.onload = ()=> {
          // Prompt for camera permission on image load
          requestCameraPermissionAndStream().then((stream) => {
            if (!stream) {
              alert('AR requires camera access.');
              return;
            }
            cameraFeed.srcObject = stream;
            cameraFeed.style.display = 'block'; // for debugging visibility (set to none in production)
            cameraFeed.width = 0; cameraFeed.height = 0;
            if (arStarted) {
              alert("For a new image, please refresh and upload again. MindAR dynamic target is experimental.");
            } else {
              startMindAR();
            }
          });
        };
      };
      reader.readAsDataURL(file);
    };

    // CAMERA HANDLING Fix: Both permission and stream for debugging camera use
    async function requestCameraPermissionAndStream() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return false;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: {ideal: "environment"} }, audio: false });
        return stream;
      } catch (e) {
        return false;
      }
    }

    // Start MindAR and hide instruction overlay
    function startMindAR() {
      sceneEl.components["mindar-image"].start().then(() => {
        arStarted = true;
        document.getElementById('instructions').style.display = 'none';
        drawOverlayGroup();
      }).catch(err => {
        alert('Error starting AR: ' + err);
      });
    }

    function clearOverlayGroup() {
      while(overlayGroup.firstChild) overlayGroup.removeChild(overlayGroup.firstChild);
    }

    // Helper to draw overlays, now with bolder lines and new complex-relationship overlays
    function drawOverlayGroup() {
      clearOverlayGroup();
      const w = 1, h = 0.7;
      // Lines are now thicker
      const colorAlpha = "0.97";
      const bold = 0.036; // standard
      const dashBold = 0.025; // dash
      function addLine(x1, y1, x2, y2, col="#FF0", linewidth=bold, dash) {
        const seg = document.createElement("a-entity");
        seg.setAttribute("line", {
          start: `${x1} ${y1} 0.001`,
          end: `${x2} ${y2} 0.001`,
          color: col,
          opacity: colorAlpha,
          linewidth: linewidth,
          dashSize: dash ? dash : 0, // enable dash if needed
          gapSize: dash ? dash : 0
        });
        overlayGroup.appendChild(seg);
      }
      if(overlays.thirds){
        for(let i=1;i<=2;i++){
          addLine(w*i/3,-h/2,w*i/3,h/2,"#FFD600",bold);
          addLine(0,-h/2+i*(h/3),w,-h/2+i*(h/3),"#FFD600",bold);
        }
      }
      if(overlays.diagonals){
        addLine(0,-h/2,w,h/2,"#00D4F6",bold);
        addLine(w,-h/2,0,h/2,"#00D4F6",bold);
        const dashSize = 0.025;
        for(let i=1;i<=2;i++){
          addLine(w*i/3,-h/2,w,i*h/3-h/2,"#00D4F6",dashBold,dashSize);
          addLine(0,-h/2+i*(h/3),w*i/3,h/2,"#00D4F6",dashBold,dashSize);
          addLine(w-w*i/3,-h/2,0,i*h/3-h/2,"#00D4F6",dashBold,dashSize);
          addLine(w,-h/2+i*(h/3),w-w*i/3,h/2,"#00D4F6",dashBold,dashSize);
        }
      }
      if(overlays.golden){
        const phi = 0.618;
        addLine(w*phi,-h/2,w*phi,h/2,"#51FF3D",bold*0.92);
        addLine(w*(1-phi),-h/2,w*(1-phi),h/2,"#51FF3D",bold*0.92);
        addLine(0,-h/2+h*phi,w,-h/2+h*phi,"#51FF3D",bold*0.92);
        addLine(0,-h/2+h*(1-phi),w,-h/2+h*(1-phi),"#51FF3D",bold*0.92);
        function goldenSpiral(cx,cy,flipX,flipY,col){
          let pts=[];
          let a=0, maxA=1.6*Math.PI, steps=90;
          let r0 = (Math.min(w,h)*0.56)*0.99;
          for(let s=0;s<steps;s++){
            let r = r0 * Math.pow(phi, a/(2*Math.PI));
            let x=cx + flipX*r*Math.cos(a);
            let y=cy + flipY*r*Math.sin(a);
            pts.push([x,y]);
            a += maxA/steps;
          }
          for(let i=1;i<pts.length;i++){
            addLine(pts[i-1][0],pts[i-1][1],pts[i][0],pts[i][1],col,0.02);
          }
        }
        goldenSpiral(0,-h/2,1,1,"#51FF3D");
        goldenSpiral(w,-h/2,-1,1,"#51FF3D");
        goldenSpiral(0,h/2,1,-1,"#51FF3D");
        goldenSpiral(w,h/2,-1,-1,"#51FF3D");
      }
      if(overlays.perspective){
        let cx=w/2,cy=0;
        let lines = 11;
        for(let i=0;i<lines;i++){
          let angle = Math.PI*2*i/lines;
          let rx = Math.cos(angle), ry = Math.sin(angle);
          addLine(cx,cy,
            cx+rx*(w),cy+ry*(h/1.5),"#FFA542",bold*0.95);
        }
        for(let j=1;j<6;j++){
          let y=-h/2 + j*(h/6);
          addLine(0,y,w,y,"#FFA542",dashBold,0.016);
        }
      }
      if(overlays.curves){
        let pts = [];
        let C = [[0.14,-h/2+0.07],[w-0.12,h/2-0.17],[0.21,h/2-0.10]];
        for(let t=0;t<=1;t+=0.025){
          let x=(1-t)*(1-t)*C[0][0]+2*(1-t)*t*C[1][0]+t*t*C[2][0];
          let y=(1-t)*(1-t)*C[0][1]+2*(1-t)*t*C[1][1]+t*t*C[2][1];
          pts.push([x,y]);
        }
        for(let i=1;i<pts.length;i++){
          addLine(pts[i-1][0],pts[i-1][1],pts[i][0],pts[i][1],"#FFBF00",0.033);
        }
        let S = [[0.1,-h/2+0.05],[w*0.6,0],[w*0.3,h/2-0.09],[w-0.08,h/2-0.04]];
        pts=[];
        for(let t=0;t<=1;t+=0.025){
          let x=Math.pow(1-t,3)*S[0][0]+3*Math.pow(1-t,2)*t*S[1][0]+3*(1-t)*t*t*S[2][0]+t*t*t*S[3][0];
          let y=Math.pow(1-t,3)*S[0][1]+3*Math.pow(1-t,2)*t*S[1][1]+3*(1-t)*t*t*S[2][1]+t*t*t*S[3][1];
          pts.push([x,y]);
        }
        for(let i=1;i<pts.length;i++){
          addLine(pts[i-1][0],pts[i-1][1],pts[i][0],pts[i][1],"#94ffe2",0.025);
        }
      }
      if(overlays.complex){
        addLine(w/2,-h/2,w/2,h/2,"#DC5DF6",bold*1.12);
        addLine(0,h/2,w,h/2,"#DC5DF6",bold*1.12);
        addLine(0,-h/2,w,h/2,"#20F629",0.031);
        addLine(w,-h/2,0,h/2,"#20F629",0.031);
        let cx=w/2, cy=0, rx=w/2*0.88, ry=h/2*0.88;
        let lastCircle=null;
        for(let a=0;a<360;a+=8){
          let rad = a*Math.PI/180, nx = cx + rx*Math.cos(rad), ny = cy + ry*Math.sin(rad);
          if(lastCircle) addLine(lastCircle[0], lastCircle[1], nx, ny, "#41FCFF",0.024);
          lastCircle = [nx, ny];
        }
        function star(cx,cy,r,points,col,wide){
          let arr = [];
          for(let i=0;i<points;i++){
            let rad = (i/points)*2*Math.PI - Math.PI/2;
            arr.push([cx+r*Math.cos(rad),cy+r*Math.sin(rad)]);
          }
          for(let step=2;step<=(points>>1);step++){
            for(let i=0;i<points;i++){
              let j = (i+step)%points;
              addLine(arr[i][0],arr[i][1],arr[j][0],arr[j][1],col,wide);
            }
          }
        }
        star(w/2,0,Math.min(w,h)/2*0.62,5,"#FC3898",0.023);
        star(w/2,0,Math.min(w,h)/2*0.54,6,"#45D1F6",0.018);
        for(let r=0;r<8;r++){
          let ang=Math.PI*2*r/8;
          addLine(w/2,0,w/2+Math.cos(ang)*(w/2),0+Math.sin(ang)*(h/2),"#FCA237",0.018);
        }
      }
    }
  </script>
  <!-- Enhanced A-Frame line component with linewidth support -->
  <script src="https://cdn.jsdelivr.net/npm/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
  <script src="https://unpkg.com/three@0.153.0/examples/js/lines/Line2.js"></script>
  <script src="https://unpkg.com/three@0.153.0/examples/js/lines/LineGeometry.js"></script>
  <script src="https://unpkg.com/three@0.153.0/examples/js/lines/LineMaterial.js"></script>
  <script>
    // Enhanced "line" component with linewidth interpreted by THREE.Line2 for wide lines
    AFRAME.registerComponent('line', {
      schema: {
        start: {type: 'vec3'},
        end: {type: 'vec3'},
        color: {type:'color',default:'#fff'},
        opacity: {type: 'number', default:1},
        linewidth: {type:'number',default:0.025},
        dashSize: {type:'number',default:0},
        gapSize: {type:'number',default:0}
      },
      init: function(){
        const data = this.data;
        if (THREE.Line2 && THREE.LineGeometry && THREE.LineMaterial) {
          let positions = [
            data.start[0], data.start[1], data.start[2],
            data.end[0], data.end[1], data.end[2]
          ];
          let geometry = new THREE.LineGeometry();
          geometry.setPositions(positions);
          let matOpt = {
            color: new THREE.Color(data.color),
            linewidth: data.linewidth * 10,
            transparent: true,
            opacity: data.opacity,
            dashed: data.dashSize > 0,
            dashSize: data.dashSize,
            gapSize: data.gapSize,
            depthTest: false
          };
          let mat = new THREE.LineMaterial(matOpt);
          mat.resolution.set(window.innerWidth, window.innerHeight);
          let line;
          if(matOpt.dashed){
            line = new THREE.Line2(geometry, mat);
            line.computeLineDistances();
          } else {
            line = new THREE.Line2(geometry, mat);
          }
          this.el.setObject3D('mesh', line);
        } else {
          let geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(...data.start),
            new THREE.Vector3(...data.end)
          ]);
          let mat = new THREE.LineBasicMaterial({
            color: new THREE.Color(data.color),
            transparent: true,
            opacity: data.opacity
          });
          let line = new THREE.Line(geometry, mat);
          this.el.setObject3D('mesh', line);
        }
      }
    });
    window.addEventListener('resize', ()=>{
      document.querySelectorAll('a-entity[line]').forEach(el=>{
        if(el.getObject3D('mesh')&&el.getObject3D('mesh').material&&el.getObject3D('mesh').material.resolution){
          el.getObject3D('mesh').material.resolution.set(window.innerWidth,window.innerHeight);
        }
      });
    });
  </script>
</body>
</html>
