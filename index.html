<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SDR Sweeper — Web SDR Spectrum Sweeper</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1720; --accent:#06f; --muted:#98a0b3; --green:#2dd4bf;
      --font: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#07101a);color:#e6eef6;font-family:var(--font);}
    .app{display:grid;grid-template-columns:320px 1fr;gap:16px;height:100vh;padding:16px;box-sizing:border-box}
    .panel{background:linear-gradient(180deg,var(--panel),#081017);padding:12px;border-radius:8px;box-shadow:0 6px 20px rgba(2,6,23,.6);overflow:auto}
    h1{font-size:16px;margin:0 0 8px 0}
    label{display:block;font-size:13px;margin:10px 0 4px;color:var(--muted)}
    input[type="text"],input[type="number"],select{width:100%;padding:6px 8px;border-radius:6px;border:1px solid rgba(255,255,255,.06);background:transparent;color:inherit}
    button{background:var(--accent);border:none;color:#001;padding:8px 10px;border-radius:8px;font-weight:600;cursor:pointer;margin-right:8px}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,.06);color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center}
    .small{font-size:12px;color:var(--muted)}
    canvas{width:100%;height:100%;display:block;border-radius:8px;background:#000}
    .status{font-size:12px;margin-top:8px;color:var(--muted)}
    .controls{display:grid;gap:8px}
    .footer{font-size:12px;color:var(--muted);margin-top:12px}
    .flex-between{display:flex;justify-content:space-between;align-items:center}
  </style>
</head>
<body>
  <div class="app">
    <div class="panel" style="min-width:280px;">
      <h1>SDR Sweeper</h1>
      <div class="controls">
        <label>WebSocket URL (SDR backend)</label>
        <input id="wsUrl" type="text" value="ws://localhost:8888/" />

        <label>Connection</label>
        <div class="row">
          <button id="connectBtn">Connect</button>
          <button id="disconnectBtn" class="ghost">Disconnect</button>
          <label style="margin-left:8px"><input id="autoConnect" type="checkbox" /> Auto-reconnect</label>
        </div>

        <label>SDR / Server Settings</label>
        <label class="small">Center frequency reported by server (Hz)</label>
        <input id="displayCenter" type="text" disabled placeholder="read from server/simulation" />
        <label class="small">Sample rate reported by server (Hz)</label>
        <input id="displaySampleRate" type="text" disabled placeholder="read from server/simulation" />

        <hr style="border:0;border-top:1px dashed rgba(255,255,255,.04)" />

        <label>Sweep Range & Timing</label>
        <div class="row">
          <div style="flex:1">
            <label class="small">Start (Hz)</label>
            <input id="startFreq" type="number" value="88000000" />
          </div>
          <div style="flex:1">
            <label class="small">Stop (Hz)</label>
            <input id="stopFreq" type="number" value="108000000" />
          </div>
        </div>
        <div class="row">
          <div style="flex:1">
            <label class="small">Step (Hz)</label>
            <input id="stepFreq" type="number" value="200000" />
          </div>
          <div style="flex:1">
            <label class="small">Dwell (ms)</label>
            <input id="dwellMs" type="number" value="250" />
          </div>
        </div>

        <div class="row">
          <label><input id="direction" type="checkbox" /> Sweep up then down (ping-pong)</label>
        </div>

        <div class="row" style="margin-top:8px">
          <button id="startSweep">Start Sweep</button>
          <button id="stopSweep" class="ghost">Stop Sweep</button>
          <button id="simulateBtn" class="ghost">Use Simulation</button>
        </div>

        <div class="status" id="status">Status: idle</div>

        <div class="footer">
          Notes:
          <ul style="padding-left:18px;margin:6px 0 0 0">
            <li>Backend should accept WebSocket and expose spectrum data frames and tune commands.</li>
            <li>Server message format (recommended): JSON frames with type "spectrum": {type:"spectrum", centerFreq, sampleRate, bins: [magnitude floats], timestamp}</li>
            <li>Client tune command (recommended): {type:"tune", frequency: <Hz>}</li>
            <li>If you don't have a backend enabled, click "Use Simulation".</li>
          </ul>
        </div>
      </div>
    </div>

    <div style="display:flex;flex-direction:column;gap:12px;">
      <div class="panel" style="flex:1;display:flex;flex-direction:column;padding:8px">
        <div class="flex-between">
          <div>
            <strong>Spectrum</strong>
            <span style="color:var(--muted);font-size:12px;margin-left:8px" id="freqLabel">-- Hz</span>
          </div>
          <div class="small">FFT bins: <span id="binsCount">--</span></div>
        </div>
        <canvas id="spectrumCanvas" width="1600" height="300" style="margin-top:8px"></canvas>
      </div>

      <div class="panel" style="height:260px;padding:8px;">
        <div class="flex-between">
          <strong>Waterfall</strong>
          <div class="small">Scroll: <span id="wfScroll">down</span></div>
        </div>
        <canvas id="waterfallCanvas" width="1600" height="240" style="margin-top:8px"></canvas>
      </div>
    </div>
  </div>

  <script>
    // SDR Sweeper - single-file client
    // How this works:
    //  - Connect to a WebSocket backend that sends spectrum frames:
    //      { type: "spectrum", centerFreq: number (Hz), sampleRate: number (Hz), bins: [float magnitudes], timestamp?: number }
    //  - Client can request the backend to retune by sending:
    //      { type: "tune", frequency: number (Hz) }
    //  - If no backend is present, enable Simulation Mode which generates plausible spectra and accepts tune commands locally.
    //
    // Note: Typical setup: rtl_tcp or other SDR server -> small WebSocket proxy that maps JSON <-> rtl_tcp or remote API.
    // Example simple protocol: send {"type":"tune","frequency":91500000} over the websocket to request tuning.

    (function(){
      const wsUrlEl = document.getElementById('wsUrl');
      const connectBtn = document.getElementById('connectBtn');
      const disconnectBtn = document.getElementById('disconnectBtn');
      const autoConnectEl = document.getElementById('autoConnect');
      const displayCenter = document.getElementById('displayCenter');
      const displaySampleRate = document.getElementById('displaySampleRate');

      const startFreqEl = document.getElementById('startFreq');
      const stopFreqEl = document.getElementById('stopFreq');
      const stepFreqEl = document.getElementById('stepFreq');
      const dwellMsEl = document.getElementById('dwellMs');
      const directionEl = document.getElementById('direction');

      const startBtn = document.getElementById('startSweep');
      const stopBtn = document.getElementById('stopSweep');
      const simulateBtn = document.getElementById('simulateBtn');
      const statusEl = document.getElementById('status');
      const binsCountEl = document.getElementById('binsCount');
      const freqLabelEl = document.getElementById('freqLabel');
      const wfScrollEl = document.getElementById('wfScroll');

      const spectrumCanvas = document.getElementById('spectrumCanvas');
      const waterfallCanvas = document.getElementById('waterfallCanvas');
      const sCtx = spectrumCanvas.getContext('2d');
      const wCtx = waterfallCanvas.getContext('2d');

      let ws = null;
      let connected = false;
      let autoReconnect = true;
      let usingSimulation = false;

      let latestCenter = 0;
      let latestSampleRate = 2e6;
      let latestBins = new Float32Array(1024);

      let sweepRunning = false;
      let sweepAbort = false;
      let sweepDirectionForward = true;

      // Waterfall buffer: maintain ImageData rows appended top-to-bottom
      const wfWidth = waterfallCanvas.width;
      const wfHeight = waterfallCanvas.height;
      const wfImage = wCtx.createImageData(wfWidth, wfHeight);
      // start with black
      for(let i=0;i<wfImage.data.length;i+=4){
        wfImage.data[i]=0; wfImage.data[i+1]=0; wfImage.data[i+2]=0; wfImage.data[i+3]=255;
      }
      wCtx.putImageData(wfImage,0,0);

      // Connect/disconnect handlers
      connectBtn.addEventListener('click', () => {
        usingSimulation = false;
        connectWebSocket(wsUrlEl.value);
      });
      disconnectBtn.addEventListener('click', () => {
        autoReconnect = false;
        if(ws) ws.close();
      });

      simulateBtn.addEventListener('click', () => {
        usingSimulation = !usingSimulation;
        if(usingSimulation){
          status('Using simulation mode — no network required');
          if(ws){ ws.close(); ws = null; connected = false; }
          displayCenter.value = '';
          displaySampleRate.value = '';
        } else {
          status('Simulation off');
        }
      });

      autoConnectEl.addEventListener('change', () => autoReconnect = autoConnectEl.checked);

      function connectWebSocket(url){
        if(ws){ try{ ws.close(); }catch(e){} ws=null; }
        status('Connecting to ' + url + ' ...');
        try {
          ws = new WebSocket(url);
        } catch(err) {
          status('WebSocket create failed: ' + err.message);
          return;
        }

        ws.binaryType = 'arraybuffer';
        ws.addEventListener('open', () => {
          connected = true;
          status('WebSocket connected');
          // request initial spectrum or server state if your backend supports it:
          try { ws.send(JSON.stringify({type:'request_status'})); } catch(e){}
        });

        ws.addEventListener('message', ev => {
          // Accept JSON text. For binary (e.g., raw float32 bins), you'd need to adapt.
          if(typeof ev.data === 'string'){
            try {
              const msg = JSON.parse(ev.data);
              handleServerMessage(msg);
            } catch(err){
              console.warn('Failed parse text message', err);
            }
          } else if(ev.data instanceof ArrayBuffer){
            // Support binary float32 array: simple convention: first 8 bytes = centerFreq (float64) + sampleRate (float64) then float32 bins
            const buf = ev.data;
            if(buf.byteLength >= 16){
              const view = new DataView(buf);
              const center = view.getFloat64(0, true);
              const sampleRate = view.getFloat64(8, true);
              const floatBuf = new Float32Array(buf, 16);
              updateSpectrum(center, sampleRate, floatBuf);
            }
          }
        });

        ws.addEventListener('close', () => {
          connected = false;
          status('WebSocket closed');
          if(autoReconnect && !usingSimulation){
            status('Reconnecting in 1s...');
            setTimeout(()=>connectWebSocket(url), 1000);
          }
        });

        ws.addEventListener('error', e => {
          console.error('WebSocket error', e);
          status('WebSocket error (see console)');
        });
      }

      function handleServerMessage(msg){
        if(!msg || !msg.type) return;
        if(msg.type === 'spectrum'){
          // expected: {type:"spectrum", centerFreq, sampleRate, bins: [...]}
          const bins = new Float32Array(msg.bins.length);
          for(let i=0;i<msg.bins.length;i++) bins[i] = msg.bins[i];
          updateSpectrum(msg.centerFreq, msg.sampleRate, bins);
        } else if(msg.type === 'status'){
          // optional server status message
          if(msg.centerFreq) displayCenter.value = msg.centerFreq.toLocaleString();
          if(msg.sampleRate) displaySampleRate.value = msg.sampleRate.toLocaleString();
        } else if(msg.type === 'tuned'){
          // confirmation of tuning
          status('Server tuned to ' + (msg.frequency || '?') + ' Hz');
        }
      }

      function sendTune(freq){
        if(usingSimulation){
          // simulation accepts the tune by storing current center
          latestCenter = freq;
          displayCenter.value = latestCenter.toLocaleString();
          return;
        }
        if(!ws || ws.readyState !== WebSocket.OPEN){
          status('WebSocket not open, cannot tune');
          return;
        }
        const cmd = { type: 'tune', frequency: Number(freq) };
        try {
          ws.send(JSON.stringify(cmd));
        } catch(err){
          console.warn('send error', err);
        }
      }

      function updateSpectrum(centerFreq, sampleRate, bins){
        latestCenter = centerFreq || latestCenter;
        latestSampleRate = sampleRate || latestSampleRate;
        latestBins = Float32Array.from(bins);
        displayCenter.value = Math.round(latestCenter).toLocaleString();
        displaySampleRate.value = Math.round(latestSampleRate).toLocaleString();
        binsCountEl.textContent = latestBins.length;
        // update visualization via RAF loop (below)
      }

      // Visualization
      function drawSpectrum(){
        const w = spectrumCanvas.width;
        const h = spectrumCanvas.height;
        sCtx.clearRect(0,0,w,h);

        // Background gradient
        const g = sCtx.createLinearGradient(0,0,0,h);
        g.addColorStop(0,'rgba(2,6,23,0.6)');
        g.addColorStop(1,'rgba(2,10,18,0.2)');
        sCtx.fillStyle = g;
        sCtx.fillRect(0,0,w,h);

        // If no bins, show message
        if(!latestBins || latestBins.length===0){
          sCtx.fillStyle = '#9aa6b8';
          sCtx.font = '14px sans-serif';
          sCtx.fillText('No spectrum data yet', 12, 24);
          requestAnimationFrame(drawSpectrum);
          return;
        }
        // Convert bins (assumed magnitude in dB or linear). We'll scale.
        const bins = latestBins;
        const n = bins.length;
        // find min/max for autoscaling
        let min = Infinity, max = -Infinity;
        for(let i=0;i<n;i++){ const v = bins[i]; if(v<min) min=v; if(v>max) max=v; }
        // Expand range slightly
        if(min === max){ min = max - 1; }
        const range = max - min;

        // draw grid lines
        sCtx.strokeStyle = 'rgba(255,255,255,0.04)';
        sCtx.lineWidth = 1;
        sCtx.beginPath();
        for(let i=0;i<=4;i++){
          const y = 8 + (h-32)*(i/4);
          sCtx.moveTo(0,y); sCtx.lineTo(w,y);
        }
        sCtx.stroke();

        // draw spectrum polyline
        sCtx.beginPath();
        for(let i=0;i<n;i++){
          const x = Math.floor((i / (n-1)) * w);
          const v = bins[i];
          const y = 8 + (h-32) * (1 - ((v - min) / range));
          if(i===0) sCtx.moveTo(x,y); else sCtx.lineTo(x,y);
        }
        // fill with gradient
        sCtx.lineWidth = 1.5;
        const strokeG = sCtx.createLinearGradient(0,0,w,0);
        strokeG.addColorStop(0,'#2dd4bf'); strokeG.addColorStop(1,'#06f');
        sCtx.strokeStyle = strokeG;
        sCtx.stroke();

        // draw current center frequency marker and frequency axis
        const centerFreq = latestCenter || 0;
        freqLabelEl.textContent = (centerFreq ? Math.round(centerFreq).toLocaleString() : '--') + ' Hz (center)';

        // axis labels: mark start/stop derived from center & sample rate
        const sr = latestSampleRate || 1e6;
        const fStart = centerFreq - sr/2;
        const fStop = centerFreq + sr/2;
        sCtx.fillStyle = '#9aa6b8';
        sCtx.font = '12px sans-serif';
        sCtx.fillText(formatFreq(fStart), 6, h-8);
        const wText = sCtx.measureText(formatFreq(fStop)).width;
        sCtx.fillText(formatFreq(fStop), w - wText - 6, h-8);
        sCtx.fillText(formatFreq(centerFreq), Math.floor(w/2) - 36, h-8);

        requestAnimationFrame(drawSpectrum);
      }

      function formatFreq(hz){
        if(!isFinite(hz)) return '--';
        if(hz >= 1e9) return (hz/1e9).toFixed(3) + ' GHz';
        if(hz >= 1e6) return (hz/1e6).toFixed(3) + ' MHz';
        if(hz >= 1e3) return (hz/1e3).toFixed(3) + ' kHz';
        return Math.round(hz) + ' Hz';
      }

      // Waterfall: append new row derived from current bins
      function appendWaterfallRow(){
        const w = waterfallCanvas.width;
        const h = waterfallCanvas.height;
        // create a row of pixels width w; we map bins to width
        const bins = latestBins;
        if(!bins || bins.length===0) return;
        const n = bins.length;
        // find min/max for scaling
        let min=Infinity,max=-Infinity;
        for(let i=0;i<n;i++){const v=bins[i];if(v<min)min=v;if(v>max)max=v;}
        if(!isFinite(min) || !isFinite(max)){ return; }
        if(min===max) max = min+1;
        // Create a new row buffer RGBA
        const row = new Uint8ClampedArray(w*4);
        for(let x=0;x<w;x++){
          const binIndex = Math.floor((x / (w-1)) * (n-1));
          const v = bins[binIndex];
          const t = Math.min(1, Math.max(0, (v - min) / (max - min)));
          // color map: Jet-like -> from dark blue (cold) to cyan to yellow to red (hot)
          const color = colorMapJet(t);
          const idx = x*4;
          row[idx] = color[0]; row[idx+1] = color[1]; row[idx+2] = color[2]; row[idx+3] = 255;
        }
        // scroll existing image down by 1 pixel (or up depending on wfScroll)
        // We'll scroll down (new row at top) to show recent at top
        const img = wCtx.getImageData(0,0,w,h);
        // shift existing down by 1 pixel
        for(let y=h-1;y>=1;y--){
          const dest = y * w * 4;
          const src = (y-1) * w * 4;
          img.data.set(img.data.subarray(src, src + w*4), dest);
        }
        // set top row
        img.data.set(row, 0);
        wCtx.putImageData(img, 0, 0);
      }

      function colorMapJet(t){
        // t in [0,1]
        const r = Math.floor(255 * Math.max(0, Math.min(1, 1.5 - Math.abs(4*t - 3))));
        const g = Math.floor(255 * Math.max(0, Math.min(1, 1.5 - Math.abs(4*t - 2))));
        const b = Math.floor(255 * Math.max(0, Math.min(1, 1.5 - Math.abs(4*t - 1))));
        return [r,g,b];
      }

      // animation loop to append waterfall periodically
      setInterval(() => {
        appendWaterfallRow();
      }, 120);

      // start drawing
      requestAnimationFrame(drawSpectrum);

      // Sweep logic
      startBtn.addEventListener('click', () => {
        if(sweepRunning) return;
        sweepRunning = true;
        sweepAbort = false;
        sweepDirectionForward = true;
        startSweepLoop();
      });

      stopBtn.addEventListener('click', () => {
        sweepAbort = true;
        sweepRunning = false;
        status('Sweep stopped');
      });

      async function startSweepLoop(){
        const startHz = Number(startFreqEl.value);
        const stopHz = Number(stopFreqEl.value);
        const stepHz = Number(stepFreqEl.value);
        const dwellMs = Number(dwellMsEl.value) || 200;
        const pingPong = directionEl.checked;

        if(!isFinite(startHz) || !isFinite(stopHz) || !isFinite(stepHz) || stepHz <= 0){
          status('Invalid sweep parameters');
          sweepRunning = false;
          return;
        }
        status('Sweeping from ' + formatFreq(startHz) + ' to ' + formatFreq(stopHz));

        let freq = sweepDirectionForward ? startHz : stopHz;
        let forward = true;

        while(!sweepAbort){
          // clamp
          if(forward){
            if(freq > stopHz) {
              if(pingPong) { forward = false; freq = Math.max(startHz, stopHz - stepHz);}
              else { freq = startHz; }
            }
          } else {
            if(freq < startHz){
              if(pingPong) { forward = true; freq = Math.min(stopHz, startHz + stepHz); }
              else { freq = stopHz; }
            }
          }

          sendTune(freq);

          // Wait dwellMs (but still allow abort)
          const start = performance.now();
          while(performance.now() - start < dwellMs){
            if(sweepAbort) break;
            await sleep(20);
          }

          // step
          freq = forward ? freq + stepHz : freq - stepHz;
        }

        sweepRunning = false;
      }

      function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

      function status(txt){
        statusEl.textContent = 'Status: ' + txt;
      }

      // Simulation: produce synthetic spectrum frames periodically and accept tune requests locally
      let simTimer = null;
      let simCenter = 95e6;
      function startSimulation(){
        usingSimulation = true;
        if(simTimer) clearInterval(simTimer);
        simTimer = setInterval(() => {
          // produce a set of bins with a few peaks around local signals
          const n = 1024;
          const bins = new Float32Array(n);
          const sr = 2e6;
          const center = simCenter;
          // background noise + small slope
          for(let i=0;i<n;i++){
            const noise = (Math.random()*0.6) - 0.3;
            const slope = -0.2 * (i / n);
            bins[i] = -60 + noise + slope;
          }
          // add a few peaks whose positions change slowly with center
          const peaks = [
            {offsetHz: -300e3, width: 40e3, amp: 30},
            {offsetHz: 150e3, width: 60e3, amp: 20},
            {offsetHz: 600e3, width: 120e3, amp: 18}
          ];
          for(const p of peaks){
            // position relative to center in bins
            const posHz = p.offsetHz + Math.sin(performance.now()/5000 + p.offsetHz/1e5)*20000;
            const posBin = Math.round(( (posHz + sr/2) / sr ) * (n-1));
            const widthBins = Math.max(2, Math.round(p.width / sr * n));
            for(let k=0;k<n;k++){
              const d = (k - posBin) / Math.max(1,widthBins);
              bins[k] += p.amp * Math.exp(-d*d);
            }
          }
          // occasionally a strong spur
          if(Math.random() < 0.05){
            const k = Math.floor(Math.random()*n);
            bins[k] += 40;
          }

          updateSpectrum(simCenter, sr, bins);
        }, 150);
        status('Simulation running (generating spectrum locally)');
      }
      function stopSimulation(){
        usingSimulation = false;
        if(simTimer) clearInterval(simTimer);
        simTimer = null;
      }

      // Accept tune commands in simulation mode by changing simCenter
      // We'll override sendTune to feed simulation
      const originalSendTune = sendTune;
      sendTune = function(freq){
        if(usingSimulation){
          simCenter = Number(freq);
          latestCenter = simCenter;
          displayCenter.value = Math.round(simCenter).toLocaleString();
          status('Sim tuned to ' + formatFreq(simCenter));
          return;
        }
        if(!ws || ws.readyState !== WebSocket.OPEN){
          status('WebSocket not open, cannot tune');
          return;
        }
        const cmd = { type: 'tune', frequency: Number(freq) };
        try { ws.send(JSON.stringify(cmd)); } catch(e){ console.warn(e); }
      };

      // Hook simulate button
      simulateBtn.addEventListener('click', () => {
        if(usingSimulation){
          stopSimulation();
          simulateBtn.textContent = 'Use Simulation';
        } else {
          startSimulation();
          simulateBtn.textContent = 'Stop Simulation';
        }
      });

      // Start disconnected; optionally auto-connect on load if autoConnect flag is true
      // expose a small helper console log
      window.SDRSweeper = {
        connect: connectWebSocket,
        disconnect: () => { if(ws) ws.close(); },
        sendTune: (f) => sendTune(Number(f)),
        startSimulation,
        stopSimulation
      };

      // small usability: adjust canvas resolution for device pixel ratio
      function fixCanvasResolution(){
        [spectrumCanvas, waterfallCanvas].forEach(c=>{
          const ratio = window.devicePixelRatio || 1;
          const w = c.clientWidth;
          const h = c.clientHeight;
          c.width = Math.floor(w * ratio);
          c.height = Math.floor(h * ratio);
          const ctx = c.getContext('2d');
          ctx.setTransform(ratio,0,0,ratio,0,0);
        });
      }
      window.addEventListener('resize', fixCanvasResolution);
      fixCanvasResolution();

      // initial simulation disabled
      // If you want to autostart simulation for demo:
      // startSimulation();

    })();
  </script>
</body>
</html>
