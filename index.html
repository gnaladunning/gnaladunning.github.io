<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>tvtalk ar</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no,maximum-scale=1.0,minimum-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #000;
      position: fixed;
      top: 0; left: 0;
      /* prevents scrolling on iOS */
      touch-action: none;
      overscroll-behavior: none;
    }
    body {
      /* disables tap highlight and user selection */
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      width: 100vw;
      height: 100vh;
      position: fixed;
      inset: 0;
    }
    #politicalCanvas, #videoElement {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      object-fit: cover;
      max-width: 100vw;
      max-height: 100vh;
      pointer-events: none;
      touch-action: none;
    }
    #politicalCanvas {
      z-index: 2;
      background: transparent;
      pointer-events: none;
    }
    #videoElement {
      z-index: 1;
      background: #000;
      pointer-events: none;
    }
    /* Fullscreen button styling (if not PWA/fullscreen automatically) */
    #fsbtn {
      display:none;
      position: fixed;
      bottom: 2vw; right: 2vw;
      z-index: 9999;
      background: rgba(20,20,20,0.78);
      color: #fff;
      padding: 1em 2em;
      border: none;
      border-radius: 2em;
      font-size: 1.2em;
      cursor: pointer;
      box-shadow: 0 2px 12px #0008;
    }
  </style>
</head>
<body>
<video id="videoElement" autoplay playsinline muted></video>
<canvas id="politicalCanvas"></canvas>
<button id="fsbtn">Go Fullscreen</button>
<script>
const pc = document.getElementById('politicalCanvas');
const v = document.getElementById('videoElement');
const fsBtn = document.getElementById('fsbtn');
const ctx = pc.getContext('2d');

const INTERVAL = 120000, APPEAR = 25000, DISAPPEAR = 1200, MAX = 3, FROZEN = 2000, FMIN = 1000, FMAX = 4000, HSZ = 10;
// Phrase banks...
const characters = [
  "artist", "scientist", "family", "detective", "musician", "chef", "teacher", "young athlete", "writer", "engineer",
  "child", "painter", "traveler", "doctor", "entrepreneur", "gardener", "programmer", "astronaut", "historian", "filmmaker",
  "poet", "student", "inventor", "villager", "robot", "alien", "pilot", "surgeon", "comedian", "photographer", "dancer",
  "singer", "explorer", "runner", "dreamer", "journalist", "magician", "archaeologist", "spy", "designer", "farmer",
  "mountaineer", "healer", "pilot", "baker", "racer", "leader", "scholar"
];
const actions = [
  "discovers secrets in", "creates beauty from", "races for a cure in", "finds adventure on", "unravels lies in", "is inspired by",
  "blends tradition and innovation in", "motivates others in", "trains for competition in", "explores new worlds in", "builds bridges in",
  "invents a playground game in", "is inspired by the seasons of", "learns the meaning of home in", "comforts patients in",
  "launches a startup in", "cultivates rare flowers in", "solves a bug in", "gazes at Earth from", "uncovers stories in",
  "captures moments in", "writes verses in", "restores hope in", "challenges fate in", "reunites families in", "questions reality in",
  "defends the innocent in", "seeks redemption in", "overcomes obstacles in", "transforms lives in", "dreams big in",
  "breaks barriers in", "discovers love in", "fights injustice in", "creates wonders in", "protects secrets in", "solves mysteries in",
  "journeys across", "survives against odds in", "reaches for the stars in", "unites communities in", "redefines limits in"
];
const places = [
  "their town", "an ancient city", "a haunted mansion", "a distant planet", "a busy metropolis", "the countryside", "the wilderness",
  "a futuristic lab", "a secret garden", "the open sea", "a forgotten village", "the bustling market", "the snowy mountains",
  "a mysterious forest", "the underground tunnels", "the vibrant festival", "a crowded train", "an old theater", "the abandoned factory",
  "the digital world", "the local cafe", "a remote island", "the grand library", "the university campus", "the race track",
  "the royal palace", "the secret base", "the ancient ruins", "the high school", "the busy hospital", "the newsroom", "the space station"
];
const events = [
  "during a storm", "under the full moon", "on a summer night", "at sunrise", "before the big competition", "after a mysterious phone call",
  "when the power goes out", "as the festival begins", "while secrets unravel", "as time runs out", "when hope seems lost",
  "as allies gather", "while rivals plot", "with the world watching", "as memories return", "when destiny calls", "while dreams fade",
  "as legends are born", "on the eve of change", "when the clock strikes midnight", "in the heat of battle", "as laughter fills the air",
  "while shadows creep", "when friendship blossoms", "as old wounds heal", "while a mystery deepens", "as a challenge arises"
];

// Phrase generator
const usedPhrases = new Set();
function pickDesc() {
  let tries = 0, phrase;
  do {
    const char = characters[Math.random()*characters.length|0];
    const act = actions[Math.random()*actions.length|0];
    const place = places[Math.random()*places.length|0];
    const event = events[Math.random()*events.length|0];
    phrase = `${char} ${act} ${place} ${event}`;
    tries++;
    if (usedPhrases.size > 4000) usedPhrases.clear();
  } while (usedPhrases.has(phrase) && tries < 10);
  usedPhrases.add(phrase);
  return phrase;
}

// Cluster detection
const isLight = (r,g,b) => (0.2126*r+0.7152*g+0.0722*b)/255 > 0.5;

function clusterLightPix(dat,w,h){
  const vis=new Uint8Array(w*h),cls=[];
  for(let y=0;y<h;y++)for(let x=0;x<w;x++){
    let idx=y*w+x, i=idx*4;
    if(vis[idx]||!isLight(dat[i],dat[i+1],dat[i+2])) continue;
    let q=[[x,y]],c=[];
    vis[idx]=1;
    while(q.length){
      let [cx,cy]=q.pop(); c.push([cx,cy]);
      for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){
        let nx=cx+dx,ny=cy+dy;
        if(nx<0||nx>=w||ny<0||ny>=h)continue;
        let nidx=ny*w+nx,ni=nidx*4;
        if(!vis[nidx]&&isLight(dat[ni],dat[ni+1],dat[ni+2])){q.push([nx,ny]);vis[nidx]=1;}
      }
    }
    if(c.length>18){cls.push(c);if(cls.length>=MAX)return cls;}
  }
  return cls;
}
const clusterCenter = c => c.reduce((a,[x,y])=>[a[0]+x,a[1]+y],[0,0]).map(z=>z/c.length);
const clusterSize = c => {
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(const[x,y]of c){minX=Math.min(minX,x);maxX=Math.max(maxX,x);minY=Math.min(minY,y);maxY=Math.max(maxY,y);}
  return Math.sqrt((maxX-minX)**2+(maxY-minY)**2);
};

let clusters=[], prevCenters=[], lastPara=Date.now();
function clusDiff(cur,pre){if(cur.length!==pre.length)return 1;for(let i=0;i<cur.length;i++)if(!pre[i]||Math.abs(cur[i][0]-pre[i][0])>25||Math.abs(cur[i][1]-pre[i][1])>25)return 1;return 0;}
function updateClusters(curC,curS,refresh){
  let nst=[],mt=new Set();
  for(let i=0;i<curC.length;i++){
    let c=curC[i],s=curS[i],f=-1,minD=Infinity;
    for(let j=0;j<clusters.length;j++){
      let p=clusters[j];
      if(p.status==="disappearing")continue;
      let d=Math.hypot(c[0]-p.c[0],c[1]-p.c[1]);
      if(d<60&&d<minD&&!mt.has(j)){minD=d;f=j;}
    }
    if(f!=-1){
      let p=clusters[f];
      nst.push({...p,size:s,c:c,appearS:p.appearS,status:"visible",disappearS:null,last:Date.now(),desc:refresh?pickDesc():p.desc});
      mt.add(f);
    }else{
      nst.push({c,s,desc:pickDesc(),appearS:Date.now(),status:"appearing",disappearS:null,last:Date.now()});
    }
  }
  for(let j=0;j<clusters.length;j++){
    if(mt.has(j))continue;
    let p=clusters[j];
    if(p.status==="disappearing"&&p.disappearS&&Date.now()-p.disappearS<DISAPPEAR)nst.push(p);
    else if(p.status!=="disappearing")nst.push({...p,status:"disappearing",disappearS:Date.now()});
  }
  clusters = nst.slice(0,MAX);
}
function updateDescTrans(){
  const now=Date.now();
  for(let c of clusters){
    if(c.status==="appearing"&&c.appearS){
      let t=(now-c.appearS)/APPEAR;
      c.appearP=Math.min(1,t);
      if(c.appearP>=1){c.status="visible";c.appearS=null;c.appearP=1;}
    }
    if(c.status==="disappearing"&&c.disappearS){let t=(now-c.disappearS)/DISAPPEAR;c.disappearP=Math.min(1,t);}
  }
}

const frozen={active:false,text:""};
let nextTimeout=null;
function scheduleFreeze(){
  clearTimeout(nextTimeout);
  nextTimeout = setTimeout(startFreeze, Math.random()*(FMAX-FMIN)+FMIN);
}
function startFreeze(){
  frozen.active = true;
  frozen.text = pickDesc();
  setTimeout(()=>{
    frozen.active = false;
    scheduleFreeze();
  }, FROZEN);
}
function drawFrozen(ctx,text){
  let maxF=Math.round(Math.min(pc.width,pc.height)/12),minF=20,fnt=maxF,maxW=pc.width*0.95,maxH=pc.height*0.92;
  ctx.font=`bold ${fnt}px Arial,sans-serif`;
  let fits=0,lines=[text];
  while(!fits&&fnt>=minF){
    ctx.font=`bold ${fnt}px Arial,sans-serif`;
    let widest=ctx.measureText(text).width,lh=fnt*1.4,totalH=lh;
    if(widest<=maxW&&totalH<=maxH)fits=1;else{fnt-=2;}
  }
  ctx.save();ctx.globalAlpha=1;ctx.textAlign="center";ctx.textBaseline="middle";ctx.fillStyle="#FF2020";ctx.font=`bold ${fnt}px Arial,sans-serif`;
  let cx=pc.width/2,cy=pc.height/2;
  ctx.fillText(text,cx,cy);
  ctx.restore();
}

// Bezier curves between clusters
function drawBezierLinks(ctx, centers){
  if (centers.length < 2) return;
  ctx.save();
  ctx.globalAlpha = 0.75;
  ctx.strokeStyle = "#FF2020";
  ctx.lineWidth = Math.max(2, Math.round(Math.min(pc.width, pc.height)/200));
  for(let i=0;i<centers.length;i++){
    for(let j=i+1;j<centers.length;j++){
      const [x1,y1] = centers[i];
      const [x2,y2] = centers[j];
      // Control points: curve bulges away from midpoint
      const mx = (x1+x2)/2, my = (y1+y2)/2;
      const dx = x2-x1, dy = y2-y1;
      const factor = 0.18;
      const cx = mx - factor*dy, cy = my + factor*dx;
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.quadraticCurveTo(cx,cy,x2,y2);
      ctx.stroke();
    }
  }
  ctx.restore();
}


function draw(){
  if(v.readyState===v.HAVE_ENOUGH_DATA&&v.videoWidth>0&&v.videoHeight>0){
    if(pc.width!==v.videoWidth||pc.height!==v.videoHeight){pc.width=v.videoWidth;pc.height=v.videoHeight;}
    ctx.clearRect(0,0,pc.width,pc.height);ctx.drawImage(v,0,0,pc.width,pc.height);
    if(frozen.active){drawFrozen(ctx,frozen.text);}
    else {
      let frame=ctx.getImageData(0,0,pc.width,pc.height),data=frame.data,cls=[],centers=[],sizes=[];
      try{cls=clusterLightPix(data,pc.width,pc.height);centers=cls.map(clusterCenter);sizes=cls.map(clusterSize);}catch(e){cls=[];centers=[];sizes=[];}
      let force=clusDiff(centers,prevCenters);
      if(force&&centers.length>0){updateClusters(centers,sizes,1);lastPara=Date.now();}
      else if(Date.now()-lastPara>=INTERVAL){updateClusters(centers,sizes,1);lastPara=Date.now();}
      else if(clusters.length===0){updateClusters(centers,sizes,1);}
      else updateClusters(centers,sizes,0);
      prevCenters=centers;
      updateDescTrans();

      if (clusters.length > 1) {
        drawBezierLinks(ctx, clusters.map(c => c.c));
      }

      for(let c of clusters){
        let[x,y]=c.c,s=c.size,fnt=Math.max(20,Math.round(Math.min(pc.width,pc.height)/24)),desc=c.desc;
        let alpha = c.status==="appearing"?c.appearP||0:c.status==="disappearing"?1-(c.disappearP||0):1;
        ctx.save();
        ctx.translate(x,y);
        ctx.font=`bold ${fnt}px Arial,sans-serif`;ctx.textAlign="center";ctx.textBaseline="middle";ctx.globalAlpha=alpha;ctx.fillStyle="#FF2020";
        ctx.fillText(desc,0,0);
        ctx.restore();
      }
    }
  }
  requestAnimationFrame(draw);
}

// Camera access
navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false})
  .then(s=>{
    v.srcObject=s;v.play();v.addEventListener('loadedmetadata',()=>{
      if(v.videoWidth>0&&v.videoHeight>0){pc.width=v.videoWidth;pc.height=v.videoHeight;}
      else{pc.width=window.innerWidth;pc.height=window.innerHeight;}
      draw();scheduleFreeze();
    });
  }).catch(()=>alert('camera access denied or unavailable'));

// Fullscreen logic
function handleFullscreen() {
  if (window.matchMedia('(display-mode: fullscreen)').matches) return;
  if (document.fullscreenElement) return;
  fsBtn.style.display = 'block';
}
fsBtn.addEventListener('click',()=>{
  document.documentElement.requestFullscreen?.();
  fsBtn.style.display='none';
});
document.addEventListener('fullscreenchange',()=>{
  if(document.fullscreenElement) fsBtn.style.display='none';
  else handleFullscreen();
});

// Resize logic
function resizeFullScreen() {
  pc.width = window.innerWidth;
  pc.height = window.innerHeight;
}
window.addEventListener('resize', resizeFullScreen);
window.addEventListener('orientationchange', () => {
  setTimeout(resizeFullScreen, 500);
});
window.addEventListener('load', ()=>{
  resizeFullScreen();
  handleFullscreen();
});

/* Hide browser UI as best possible (works on iOS if added to homescreen as PWA) */
if('ontouchstart' in window){
  window.addEventListener('touchmove', e => e.preventDefault(), {passive:false});
}
</script>
</body>
</html>
