<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Compositional Geometry Analyzer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <style>
    body {
      font-family: sans-serif;
      background: #222;
      color: #fff;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 900px;
      margin: 40px auto;
      background: #292929;
      box-shadow: 0 0 20px #111;
      border-radius: 10px;
      padding: 32px 16px 32px 16px;
      position: relative;
    }
    h1 {
      text-align: center;
      margin-top: 0;
    }
    #imageInput {
      margin: 20px auto;
      display: block;
    }
    .canvas-wrap {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #181818;
      min-height: 420px;
      border-radius: 8px;
      overflow: auto;
      width: 100%;
      /* Removed fixed min-height so it can grow with image aspect ratio */
    }
    #imgCanvas, #overlayCanvas {
      position: absolute;
      top: 0; left: 0;
      z-index: 0;
      border-radius: 8px;
      pointer-events: none;
      width: 100%;
      height: 100%;
      image-rendering: auto;
    }
    #overlayCanvas {
      z-index: 2;
      pointer-events: auto;
      background: transparent;
    }
    .controls {
      text-align: center;
      margin: 1rem 0 0 0;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5em 1em;
    }
    .controls label {
      margin-right: 0.7em;
      font-size: 1rem;
      display: flex;
      align-items: center;
    }
    .desc {
      padding: 1em;
      max-width: 700px;
      margin: 0 auto 2em auto;
      background: #222;
      border-radius: 6px;
      font-size: 1.1em;
      color: #ccc;
    }
    @media (max-width:700px) {
      .container{padding:8px;}
      .desc{padding:8px;}
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Compositional Geometry Analyzer</h1>
    <div class="desc">
      Upload an image or painting to reveal underlying compositional geometry: rule-of-thirds, diagonals, curves, and perspective overlays.<br>
      Use the checkboxes to toggle different overlays on the picture.<br>
      <strong>For AI and art analysis purposes only.</strong>
    </div>
    <input id="imageInput" type="file" accept="image/*"/>
    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="imgCanvas"></canvas>
      <canvas id="overlayCanvas"></canvas>
    </div>
    <div class="controls">
      <label><input type="checkbox" id="thirdsChk" checked onchange="updateOverlay()"> Rule of Thirds</label>
      <label><input type="checkbox" id="diagonalsChk" checked onchange="updateOverlay()"> Diagonals ("Baroque" and "Sinister")</label>
      <label><input type="checkbox" id="goldenChk" onchange="updateOverlay()"> Golden Ratio</label>
      <label><input type="checkbox" id="perspectiveChk" onchange="updateOverlay()"> Perspective Grid</label>
      <label><input type="checkbox" id="curvesChk" onchange="updateOverlay()"> Dynamic Curves</label>
      <button id="clearBtn" type="button" style="margin-left:1em;">Clear Image</button>
    </div>
  </div>
  <script>
    const imgCanvas = document.getElementById('imgCanvas');
    const imgCtx = imgCanvas.getContext('2d');
    const overlayCanvas = document.getElementById('overlayCanvas');
    const overlayCtx = overlayCanvas.getContext('2d');
    const imageInput = document.getElementById('imageInput');
    const canvasWrap = document.getElementById('canvasWrap');
    let img = null;
    let naturalW = 400, naturalH = 300;
    let displayW = 400, displayH = 300;

    function fitSizeToContainer(imgW, imgH) {
      // Container width is .container minus padding, leave some margin if smaller screen
      const pad = 48;
      const maxCW = Math.min(canvasWrap.offsetWidth || 850, window.innerWidth - pad, 900 - pad);
      const maxCH = Math.min(520, window.innerHeight - 240);
      // Fit image inside maxCW x maxCH while preserving aspect ratio
      const scale = Math.min(maxCW / imgW, maxCH / imgH, 1.0);
      return {
        width: Math.round(imgW * scale),
        height: Math.round(imgH * scale)
      };
    }

    function resizeCanvases(w, h) {
      // Set canvas sizes and adjust display size to fit container for responsive scaling
      [imgCanvas, overlayCanvas].forEach(c => {
        c.width = w;
        c.height = h;
        c.style.width = w + "px";
        c.style.height = h + "px";
      });
      canvasWrap.style.minHeight = h + "px";
      canvasWrap.style.height = h + "px";
      canvasWrap.style.width = w + "px";
      canvasWrap.style.maxWidth = "100%";
    }

    function drawImageOnCanvas(image) {
      if (!image) return;
      naturalW = image.naturalWidth;
      naturalH = image.naturalHeight;
      // Fit to window while preserving aspect
      const {width, height} = fitSizeToContainer(naturalW, naturalH);
      displayW = width;
      displayH = height;
      resizeCanvases(displayW, displayH);
      imgCtx.clearRect(0,0,displayW,displayH);
      // Draw so the full image is visible and undistorted
      imgCtx.drawImage(image, 0, 0, naturalW, naturalH, 0, 0, displayW, displayH);
      updateOverlay();
    }

    imageInput.addEventListener('change', e => {
      const file = e.target.files[0];
      if(!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        img = new window.Image();
        img.onload = function() {
          drawImageOnCanvas(img);
        }
        img.src = evt.target.result;
      }
      reader.readAsDataURL(file);
    });

    document.getElementById('clearBtn').onclick = function() {
      imageInput.value = "";
      img = null;
      overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
      imgCtx.clearRect(0,0,imgCanvas.width,imgCanvas.height);
      resizeCanvases(400,300);
    }

    // Real-time overlay checkboxes: redraw on any change
    // (Handled via inline onchange above & below for extra robustness)
    ['thirdsChk', 'diagonalsChk', 'goldenChk', 'perspectiveChk', 'curvesChk'].forEach(id => {
      document.getElementById(id).addEventListener('change', updateOverlay);
    });

    window.addEventListener('resize', () => {
      if (img) drawImageOnCanvas(img); // refit after window size changes
    });

    function updateOverlay() {
      // Redraw overlays, always showing full image (never cropped!)
      overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
      if (!img) return;
      if (document.getElementById('thirdsChk').checked)
        drawThirds();
      if (document.getElementById('diagonalsChk').checked)
        drawDiagonals();
      if (document.getElementById('goldenChk').checked)
        drawGoldenRatio();
      if (document.getElementById('perspectiveChk').checked)
        drawPerspectiveGrid();
      if (document.getElementById('curvesChk').checked)
        drawDynamicCurves();
    }

    // --- Overlay Drawing Functions ---

    function drawThirds() {
      const w = overlayCanvas.width, h = overlayCanvas.height;
      overlayCtx.save();
      overlayCtx.strokeStyle = "rgba(255,255,0,0.7)";
      overlayCtx.lineWidth = 2;
      for(let i=1;i<=2;i++) {
        overlayCtx.beginPath();
        overlayCtx.moveTo(i*w/3,0); overlayCtx.lineTo(i*w/3,h);
        overlayCtx.stroke();
        overlayCtx.beginPath();
        overlayCtx.moveTo(0,i*h/3); overlayCtx.lineTo(w,i*h/3);
        overlayCtx.stroke();
      }
      overlayCtx.restore();
    }

    function drawDiagonals() {
      const w = overlayCanvas.width, h = overlayCanvas.height;
      overlayCtx.save();
      overlayCtx.strokeStyle = "rgba(0,200,255,0.7)";
      overlayCtx.lineWidth = 2;
      overlayCtx.beginPath();
      overlayCtx.moveTo(0,0); overlayCtx.lineTo(w,h); // Baroque
      overlayCtx.stroke();
      overlayCtx.beginPath();
      overlayCtx.moveTo(w,0); overlayCtx.lineTo(0,h); // Sinister
      overlayCtx.stroke();
      overlayCtx.setLineDash([5,6]);
      for(let i=1;i<=2;i++) {
        overlayCtx.beginPath();
        overlayCtx.moveTo(i*w/3,0); overlayCtx.lineTo(w,(i*h/3));
        overlayCtx.stroke();
        overlayCtx.beginPath();
        overlayCtx.moveTo(0, i*h/3); overlayCtx.lineTo(i*w/3,h);
        overlayCtx.stroke();
        overlayCtx.beginPath();
        overlayCtx.moveTo(w-i*w/3,0); overlayCtx.lineTo(0,(i*h/3));
        overlayCtx.stroke();
        overlayCtx.beginPath();
        overlayCtx.moveTo(w, i*h/3); overlayCtx.lineTo(w-i*w/3,h);
        overlayCtx.stroke();
      }
      overlayCtx.setLineDash([]);
      overlayCtx.restore();
    }

    function drawGoldenRatio() {
      const w = overlayCanvas.width, h = overlayCanvas.height;
      const phi = 0.618;
      overlayCtx.save();
      overlayCtx.strokeStyle = "rgba(148, 255, 110, 0.80)";
      overlayCtx.lineWidth = 2;
      // Vertical
      overlayCtx.beginPath();
      overlayCtx.moveTo(w*phi,0); overlayCtx.lineTo(w*phi,h);
      overlayCtx.stroke();
      overlayCtx.beginPath();
      overlayCtx.moveTo(w*(1-phi),0); overlayCtx.lineTo(w*(1-phi),h);
      overlayCtx.stroke();
      // Horizontal
      overlayCtx.beginPath();
      overlayCtx.moveTo(0,h*phi); overlayCtx.lineTo(w,h*phi);
      overlayCtx.stroke();
      overlayCtx.beginPath();
      overlayCtx.moveTo(0,h*(1-phi)); overlayCtx.lineTo(w,h*(1-phi));
      overlayCtx.stroke();
      overlayCtx.restore();
      drawGoldenSpirals(w, h);
    }

    function drawGoldenSpirals(w, h) {
      overlayCtx.save();
      overlayCtx.strokeStyle = "rgba(148,255,110,0.50)";
      overlayCtx.lineWidth = 2;
      function drawSpiral(x, y, dx, dy, dir) {
        let a = 0, maxA = 1.5*Math.PI, steps = 80;
        let scale = Math.min(w,h)/2.2*0.97;
        overlayCtx.beginPath();
        for(let s=0;s<steps;s++) {
          let r = scale * Math.pow(0.618, a/(2*Math.PI));
          let px = x + dir*r*Math.cos(a)*dx - dir*r*Math.sin(a)*dy;
          let py = y + dir*r*Math.sin(a)*dx + dir*r*Math.cos(a)*dy;
          if(s===0) overlayCtx.moveTo(px, py); else overlayCtx.lineTo(px,py);
          a += maxA/steps;
        }
        overlayCtx.stroke();
      }
      drawSpiral(0,0,1,0,1); // top-left
      drawSpiral(w,0,-1,0,1); // top-right
      drawSpiral(w,h,0,-1,1); // bottom-right
      drawSpiral(0,h,0,1,1); // bottom-left
      overlayCtx.restore();
    }

    function drawPerspectiveGrid() {
      const w = overlayCanvas.width, h = overlayCanvas.height;
      const cx = w/2, cy = h/2;
      overlayCtx.save();
      overlayCtx.strokeStyle = "rgba(255,120,60,0.7)";
      overlayCtx.lineWidth = 1.2;
      let lines = 14;
      for (let i=0;i<lines;i++) {
        let angle = Math.PI*2 * i/lines;
        overlayCtx.beginPath();
        overlayCtx.moveTo(cx,cy);
        overlayCtx.lineTo(cx + Math.cos(angle)*Math.max(w,h), cy + Math.sin(angle)*Math.max(w,h));
        overlayCtx.stroke();
      }
      overlayCtx.setLineDash([5,7]);
      for(let i=1;i<10;i++) {
        let y = h * i/10;
        overlayCtx.beginPath();
        overlayCtx.moveTo(0,y); overlayCtx.lineTo(w,y);
        overlayCtx.stroke();
      }
      overlayCtx.setLineDash([]);
      overlayCtx.restore();
    }

    function drawDynamicCurves() {
      const w = overlayCanvas.width, h = overlayCanvas.height;
      overlayCtx.save();
      overlayCtx.strokeStyle = "rgba(255,220,90,0.76)";
      overlayCtx.lineWidth = 2.5;
      overlayCtx.setLineDash([8,8]);
      overlayCtx.beginPath();
      for(let t=0;t<=1;t+=0.01) {
        let x = w*0.1 + (w*0.8)*(Math.pow(t, 0.85));
        let y = h*0.1 + (h*0.8)*Math.sin(t*Math.PI/2);
        if(t===0) overlayCtx.moveTo(x,y); else overlayCtx.lineTo(x,y);
      }
      overlayCtx.stroke();
      overlayCtx.beginPath();
      for(let t=0;t<=1;t+=0.01) {
        let x = w*0.9 - (w*0.8)*Math.pow(t,0.85);
        let y = h*0.9 - (h*0.8)*Math.sin(t*Math.PI/2);
        if(t===0) overlayCtx.moveTo(x,y); else overlayCtx.lineTo(x,y);
      }
      overlayCtx.stroke();
      overlayCtx.strokeStyle = "rgba(180,255,200,0.45)";
      overlayCtx.setLineDash([4,18]);
      overlayCtx.beginPath();
      for(let t=0;t<=1;t+=0.01) {
        let x = w*(0.15 + 0.7*t + 0.09*Math.sin(t*2.5*Math.PI));
        let y = h*(0.1 + 0.8*(3*t*t-2*t*t*t));
        if(t===0) overlayCtx.moveTo(x,y); else overlayCtx.lineTo(x,y);
      }
      overlayCtx.stroke();
      overlayCtx.setLineDash([]);
      overlayCtx.restore();
    }

    // Initial setup
    resizeCanvases(400, 300);
  </script>
</body>
</html>
